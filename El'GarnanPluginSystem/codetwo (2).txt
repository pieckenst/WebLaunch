using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;

using Dalamud.Configuration;
using Dalamud.Configuration.Internal;
using Dalamud.Data;
using Dalamud.Game.Gui;
using Dalamud.Game.Text;
using Dalamud.Game.Text.Sanitizer;
using Dalamud.Game.Text.SeStringHandling;
using Dalamud.Game.Text.SeStringHandling.Payloads;
using Dalamud.Interface;
using Dalamud.Interface.Internal;
using Dalamud.Interface.Internal.Windows.PluginInstaller;
using Dalamud.Interface.Internal.Windows.Settings;
using Dalamud.Plugin.Internal;
using Dalamud.Plugin.Internal.AutoUpdate;
using Dalamud.Plugin.Internal.Types;
using Dalamud.Plugin.Internal.Types.Manifest;
using Dalamud.Plugin.Ipc;
using Dalamud.Plugin.Ipc.Exceptions;
using Dalamud.Plugin.Ipc.Internal;

using Serilog;

namespace Dalamud.Plugin;

/// <summary>
/// This class acts as an interface to various objects needed to interact with Dalamud and the game.
/// </summary>
internal sealed class DalamudPluginInterface : IDalamudPluginInterface, IDisposable
{
    private readonly LocalPlugin plugin;
    private readonly PluginConfigurations configs;
    private readonly UiBuilder uiBuilder;

    /// <summary>
    /// Initializes a new instance of the <see cref="DalamudPluginInterface"/> class.
    /// Set up the interface and populate all fields needed.
    /// </summary>
    /// <param name="plugin">The plugin this interface belongs to.</param>
    /// <param name="reason">The reason the plugin was loaded.</param>
    internal DalamudPluginInterface(
        LocalPlugin plugin,
        PluginLoadReason reason)
    {
        this.plugin = plugin;
        var configuration = Service<DalamudConfiguration>.Get();
        var dataManager = Service<DataManager>.Get();
        var localization = Service<Localization>.Get();

        this.UiBuilder = this.uiBuilder = new(plugin, plugin.Name);

        this.configs = Service<PluginManager>.Get().PluginConfigs;
        this.Reason = reason;
        this.SourceRepository = this.IsDev ? SpecialPluginSource.DevPlugin : plugin.Manifest.InstalledFromUrl;
        this.IsTesting = plugin.IsTesting;

        this.LoadTime = DateTime.Now;
        this.LoadTimeUTC = DateTime.UtcNow;

        this.GeneralChatType = configuration.GeneralChatType;
        this.Sanitizer = new Sanitizer(dataManager.Language);
        if (configuration.LanguageOverride != null)
        {
            this.UiLanguage = configuration.LanguageOverride;
        }
        else
        {
            var currentUiLang = CultureInfo.CurrentUICulture;
            if (Localization.ApplicableLangCodes.Any(langCode => currentUiLang.TwoLetterISOLanguageName == langCode))
                this.UiLanguage = currentUiLang.TwoLetterISOLanguageName;
            else
                this.UiLanguage = "en";
        }

        localization.LocalizationChanged += this.OnLocalizationChanged;
        configuration.DalamudConfigurationSaved += this.OnDalamudConfigurationSaved;
    }

    /// <summary>
    /// Event that gets fired when loc is changed
    /// </summary>
    public event IDalamudPluginInterface.LanguageChangedDelegate? LanguageChanged;

    /// <summary>
    /// Event that is fired when the active list of plugins is changed.
    /// </summary>
    public event IDalamudPluginInterface.ActivePluginsChangedDelegate? ActivePluginsChanged;

    /// <summary>
    /// Gets the reason this plugin was loaded.
    /// </summary>
    public PluginLoadReason Reason { get; }

    /// <summary>
    /// Gets a value indicating whether or not auto-updates have already completed this session.
    /// </summary>
    public bool IsAutoUpdateComplete => Service<AutoUpdateManager>.Get().IsAutoUpdateComplete;

    /// <summary>
    /// Gets the repository from which this plugin was installed.
    ///
    /// If a plugin was installed from the official/main repository, this will return the value of
    /// <see cref="SpecialPluginSource.MainRepo"/>. Developer plugins will return the value of
    /// <see cref="SpecialPluginSource.DevPlugin"/>.
    /// </summary>
    public string SourceRepository { get; }

    /// <summary>
    /// Gets the current internal plugin name.
    /// </summary>
    public string InternalName => this.plugin.InternalName;

    /// <summary>
    /// Gets the plugin's manifest.
    /// </summary>
    public IPluginManifest Manifest => this.plugin.Manifest;

    /// <summary>
    /// Gets a value indicating whether this is a dev plugin.
    /// </summary>
    public bool IsDev => this.plugin.IsDev;

    /// <summary>
    /// Gets a value indicating whether this is a testing release of a plugin.
    /// </summary>
    /// <remarks>
    /// Dev plugins have undefined behavior for this value, but can be expected to return <c>false</c>.
    /// </remarks>
    public bool IsTesting { get; }

    /// <summary>
    /// Gets the time that this plugin was loaded.
    /// </summary>
    public DateTime LoadTime { get; }

    /// <summary>
    /// Gets the UTC time that this plugin was loaded.
    /// </summary>
    public DateTime LoadTimeUTC { get; }

    /// <summary>
    /// Gets the timespan delta from when this plugin was loaded.
    /// </summary>
    public TimeSpan LoadTimeDelta => DateTime.Now - this.LoadTime;

    /// <summary>
    /// Gets the directory Dalamud assets are stored in.
    /// </summary>
    public DirectoryInfo DalamudAssetDirectory => Service<Dalamud>.Get().AssetDirectory;

    /// <summary>
    /// Gets the location of your plugin assembly.
    /// </summary>
    public FileInfo AssemblyLocation => this.plugin.DllFile;

    /// <summary>
    /// Gets the directory your plugin configurations are stored in.
    /// </summary>
    public DirectoryInfo ConfigDirectory => new(this.GetPluginConfigDirectory());

    /// <summary>
    /// Gets the config file of your plugin.
    /// </summary>
    public FileInfo ConfigFile => this.configs.GetConfigFile(this.plugin.InternalName);

    /// <summary>
    /// Gets the <see cref="UiBuilder"/> instance which allows you to draw UI into the game via ImGui draw calls.
    /// </summary>
    public IUiBuilder UiBuilder { get; private set; }

    /// <summary>
    /// Gets a value indicating whether Dalamud is running in Debug mode or the /xldev menu is open. This can occur on release builds.
    /// </summary>
    public bool IsDevMenuOpen => Service<DalamudInterface>.GetNullable() is { IsDevMenuOpen: true }; // Can be null during boot

    /// <summary>
    /// Gets a value indicating whether a debugger is attached.
    /// </summary>
    public bool IsDebugging => Debugger.IsAttached;

    /// <summary>
    /// Gets the current UI language in two-letter iso format.
    /// </summary>
    public string UiLanguage { get; private set; }

    /// <summary>
    /// Gets serializer class with functions to remove special characters from strings.
    /// </summary>
    public ISanitizer Sanitizer { get; }

    /// <summary>
    /// Gets the chat type used by default for plugin messages.
    /// </summary>
    public XivChatType GeneralChatType { get; private set; }

    /// <summary>
    /// Gets a list of installed plugins along with their current state.
    /// </summary>
    public IEnumerable<IExposedPlugin> InstalledPlugins =>
        Service<PluginManager>.Get().InstalledPlugins.Select(p => new ExposedPlugin(p));

    /// <summary>
    /// Gets the <see cref="UiBuilder"/> internal implementation.
    /// </summary>
    internal UiBuilder LocalUiBuilder => this.uiBuilder;

    /// <summary>
    /// Opens the <see cref="PluginInstallerWindow"/>, with an optional search term.
    /// </summary>
    /// <param name="openTo">The page to open the installer to. Defaults to the "All Plugins" page.</param>
    /// <param name="searchText">An optional search text to input in the search box.</param>
    /// <returns>Returns false if the DalamudInterface was null.</returns>
    public bool OpenPluginInstallerTo(PluginInstallerOpenKind openTo = PluginInstallerOpenKind.AllPlugins, string? searchText = null)
    {
        var dalamudInterface = Service<DalamudInterface>.GetNullable(); // Can be null during boot
        if (dalamudInterface == null)
        {
            return false;
        }

        dalamudInterface.OpenPluginInstallerTo(openTo);
        dalamudInterface.SetPluginInstallerSearchText(searchText ?? string.Empty);

        return true;
    }

    /// <summary>
    /// Opens the <see cref="SettingsWindow"/>, with an optional search term.
    /// </summary>
    /// <param name="openTo">The tab to open the settings to. Defaults to the "General" tab.</param>
    /// <param name="searchText">An optional search text to input in the search box.</param>
    /// <returns>Returns false if the DalamudInterface was null.</returns>
    public bool OpenDalamudSettingsTo(SettingsOpenKind openTo = SettingsOpenKind.General, string? searchText = null)
    {
        var dalamudInterface = Service<DalamudInterface>.GetNullable(); // Can be null during boot
        if (dalamudInterface == null)
        {
            return false;
        }

        dalamudInterface.OpenSettingsTo(openTo);
        dalamudInterface.SetSettingsSearchText(searchText ?? string.Empty);

        return true;
    }

    /// <summary>
    /// Opens the dev menu bar.
    /// </summary>
    /// <returns>Returns false if the DalamudInterface was null.</returns>
    public bool OpenDeveloperMenu()
    {
        var dalamudInterface = Service<DalamudInterface>.GetNullable(); // Can be null during boot
        if (dalamudInterface == null)
        {
            return false;
        }

        dalamudInterface.OpenDevMenu();
        return true;
    }

    #region IPC

    /// <inheritdoc cref="DataShare.GetOrCreateData{T}"/>
    public T GetOrCreateData<T>(string tag, Func<T> dataGenerator) where T : class
        => Service<DataShare>.Get().GetOrCreateData(tag, dataGenerator);

    /// <inheritdoc cref="DataShare.RelinquishData"/>
    public void RelinquishData(string tag)
        => Service<DataShare>.Get().RelinquishData(tag);

    /// <inheritdoc cref="DataShare.TryGetData{T}"/>
    public bool TryGetData<T>(string tag, [NotNullWhen(true)] out T? data) where T : class
        => Service<DataShare>.Get().TryGetData(tag, out data);

    /// <inheritdoc cref="DataShare.GetData{T}"/>
    public T? GetData<T>(string tag) where T : class
        => Service<DataShare>.Get().GetData<T>(tag);

    /// <summary>
    /// Gets an IPC provider.
    /// </summary>
    /// <typeparam name="TRet">The return type for funcs. Use object if this is unused.</typeparam>
    /// <param name="name">The name of the IPC registration.</param>
    /// <returns>An IPC provider.</returns>
    /// <exception cref="IpcTypeMismatchError">This is thrown when the requested types do not match the previously registered types are different.</exception>
    public ICallGateProvider<TRet> GetIpcProvider<TRet>(string name)
        => new CallGatePubSub<TRet>(name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    public ICallGateProvider<T1, TRet> GetIpcProvider<T1, TRet>(string name)
        => new CallGatePubSub<T1, TRet>(name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    public ICallGateProvider<T1, T2, TRet> GetIpcProvider<T1, T2, TRet>(string name)
        => new CallGatePubSub<T1, T2, TRet>(name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    public ICallGateProvider<T1, T2, T3, TRet> GetIpcProvider<T1, T2, T3, TRet>(string name)
        => new CallGatePubSub<T1, T2, T3, TRet>(name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    public ICallGateProvider<T1, T2, T3, T4, TRet> GetIpcProvider<T1, T2, T3, T4, TRet>(string name)
        => new CallGatePubSub<T1, T2, T3, T4, TRet>(name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    public ICallGateProvider<T1, T2, T3, T4, T5, TRet> GetIpcProvider<T1, T2, T3, T4, T5, TRet>(string name)
        => new CallGatePubSub<T1, T2, T3, T4, T5, TRet>(name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    public ICallGateProvider<T1, T2, T3, T4, T5, T6, TRet> GetIpcProvider<T1, T2, T3, T4, T5, T6, TRet>(string name)
        => new CallGatePubSub<T1, T2, T3, T4, T5, T6, TRet>(name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    public ICallGateProvider<T1, T2, T3, T4, T5, T6, T7, TRet> GetIpcProvider<T1, T2, T3, T4, T5, T6, T7, TRet>(string name)
        => new CallGatePubSub<T1, T2, T3, T4, T5, T6, T7, TRet>(name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    public ICallGateProvider<T1, T2, T3, T4, T5, T6, T7, T8, TRet> GetIpcProvider<T1, T2, T3, T4, T5, T6, T7, T8, TRet>(string name)
        => new CallGatePubSub<T1, T2, T3, T4, T5, T6, T7, T8, TRet>(name);

    /// <summary>
    /// Gets an IPC subscriber.
    /// </summary>
    /// <typeparam name="TRet">The return type for funcs. Use object if this is unused.</typeparam>
    /// <param name="name">The name of the IPC registration.</param>
    /// <returns>An IPC subscriber.</returns>
    public ICallGateSubscriber<TRet> GetIpcSubscriber<TRet>(string name)
        => new CallGatePubSub<TRet>(name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    public ICallGateSubscriber<T1, TRet> GetIpcSubscriber<T1, TRet>(string name)
        => new CallGatePubSub<T1, TRet>(name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    public ICallGateSubscriber<T1, T2, TRet> GetIpcSubscriber<T1, T2, TRet>(string name)
        => new CallGatePubSub<T1, T2, TRet>(name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    public ICallGateSubscriber<T1, T2, T3, TRet> GetIpcSubscriber<T1, T2, T3, TRet>(string name)
        => new CallGatePubSub<T1, T2, T3, TRet>(name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    public ICallGateSubscriber<T1, T2, T3, T4, TRet> GetIpcSubscriber<T1, T2, T3, T4, TRet>(string name)
        => new CallGatePubSub<T1, T2, T3, T4, TRet>(name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    public ICallGateSubscriber<T1, T2, T3, T4, T5, TRet> GetIpcSubscriber<T1, T2, T3, T4, T5, TRet>(string name)
        => new CallGatePubSub<T1, T2, T3, T4, T5, TRet>(name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    public ICallGateSubscriber<T1, T2, T3, T4, T5, T6, TRet> GetIpcSubscriber<T1, T2, T3, T4, T5, T6, TRet>(string name)
        => new CallGatePubSub<T1, T2, T3, T4, T5, T6, TRet>(name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    public ICallGateSubscriber<T1, T2, T3, T4, T5, T6, T7, TRet> GetIpcSubscriber<T1, T2, T3, T4, T5, T6, T7, TRet>(string name)
        => new CallGatePubSub<T1, T2, T3, T4, T5, T6, T7, TRet>(name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    public ICallGateSubscriber<T1, T2, T3, T4, T5, T6, T7, T8, TRet> GetIpcSubscriber<T1, T2, T3, T4, T5, T6, T7, T8, TRet>(string name)
        => new CallGatePubSub<T1, T2, T3, T4, T5, T6, T7, T8, TRet>(name);

    #endregion

    #region Configuration

    /// <summary>
    /// Save a plugin configuration(inheriting IPluginConfiguration).
    /// </summary>
    /// <param name="currentConfig">The current configuration.</param>
    public void SavePluginConfig(IPluginConfiguration? currentConfig)
    {
        if (currentConfig == null)
            return;

        this.configs.Save(currentConfig, this.plugin.InternalName, this.plugin.EffectiveWorkingPluginId);
    }

    /// <summary>
    /// Get a previously saved plugin configuration or null if none was saved before.
    /// </summary>
    /// <returns>A previously saved config or null if none was saved before.</returns>
    public IPluginConfiguration? GetPluginConfig()
    {
        // This is done to support json deserialization of plugin configurations
        // even after running an in-game update of plugins, where the assembly version
        // changes.
        // Eventually it might make sense to have a separate method on this class
        // T GetPluginConfig<T>() where T : IPluginConfiguration
        // that can invoke LoadForType() directly instead of via reflection
        // This is here for now to support the current plugin API
        foreach (var type in Assembly.GetCallingAssembly().GetTypes())
        {
            if (type.IsAssignableTo(typeof(IPluginConfiguration)))
            {
                var mi = this.configs.GetType().GetMethod("LoadForType");
                var fn = mi.MakeGenericMethod(type);
                return (IPluginConfiguration)fn.Invoke(this.configs, new object[] { this.plugin.InternalName });
            }
        }

        // this shouldn't be a thing, I think, but just in case
        return this.configs.Load(this.plugin.InternalName, this.plugin.EffectiveWorkingPluginId);
    }

    /// <summary>
    /// Get the config directory.
    /// </summary>
    /// <returns>directory with path of AppData/XIVLauncher/pluginConfig/PluginInternalName.</returns>
    public string GetPluginConfigDirectory() => this.configs.GetDirectory(this.plugin.InternalName);

    /// <summary>
    /// Get the loc directory.
    /// </summary>
    /// <returns>directory with path of AppData/XIVLauncher/pluginConfig/PluginInternalName/loc.</returns>
    public string GetPluginLocDirectory() => this.configs.GetDirectory(Path.Combine(this.plugin.InternalName, "loc"));

    #endregion

    #region Chat Links

    // TODO API9: Move to chatgui, don't allow passing own commandId

    /// <summary>
    /// Register a chat link handler.
    /// </summary>
    /// <param name="commandId">The ID of the command.</param>
    /// <param name="commandAction">The action to be executed.</param>
    /// <returns>Returns an SeString payload for the link.</returns>
    public DalamudLinkPayload AddChatLinkHandler(uint commandId, Action<uint, SeString> commandAction)
    {
        return Service<ChatGui>.Get().AddChatLinkHandler(this.plugin.InternalName, commandId, commandAction);
    }

    /// <summary>
    /// Remove a chat link handler.
    /// </summary>
    /// <param name="commandId">The ID of the command.</param>
    public void RemoveChatLinkHandler(uint commandId)
    {
        Service<ChatGui>.Get().RemoveChatLinkHandler(this.plugin.InternalName, commandId);
    }

    /// <summary>
    /// Removes all chat link handlers registered by the plugin.
    /// </summary>
    public void RemoveChatLinkHandler()
    {
        Service<ChatGui>.Get().RemoveChatLinkHandler(this.plugin.InternalName);
    }
    #endregion

    #region Dependency Injection

    /// <inheritdoc/>
    public T? Create<T>(params object[] scopedObjects) where T : class
    {
        var t = this.CreateAsync<T>(scopedObjects);
        t.Wait();

        if (t.Exception is { } e)
        {
            Log.Error(
                e,
                "{who}: Exception during {where}: {what}",
                this.plugin.Name,
                nameof(this.Create),
                typeof(T).FullName ?? typeof(T).Name);
        }

        return t.IsCompletedSuccessfully ? t.Result : null;
    }

    /// <inheritdoc/>
    public async Task<T> CreateAsync<T>(params object[] scopedObjects) where T : class =>
        (T)await this.plugin.ServiceScope!.CreateAsync(typeof(T), this.GetPublicIocScopes(scopedObjects));

    /// <inheritdoc/>
    public bool Inject(object instance, params object[] scopedObjects)
    {
        var t = this.InjectAsync(instance, scopedObjects);
        t.Wait();

        if (t.Exception is { } e)
        {
            Log.Error(
                e,
                "{who}: Exception during {where}: {what}",
                this.plugin.Name,
                nameof(this.Inject),
                instance.GetType().FullName ?? instance.GetType().Name);
        }

        return t.IsCompletedSuccessfully;
    }

    /// <inheritdoc/>
    public Task InjectAsync(object instance, params object[] scopedObjects) =>
        this.plugin.ServiceScope!.InjectPropertiesAsync(instance, this.GetPublicIocScopes(scopedObjects));

    #endregion

    /// <summary>Unregister the plugin and dispose all references.</summary>
    /// <remarks>Dalamud internal use only.</remarks>
    public void Dispose()
    {
        Service<ChatGui>.Get().RemoveChatLinkHandler(this.plugin.InternalName);
        Service<Localization>.Get().LocalizationChanged -= this.OnLocalizationChanged;
        Service<DalamudConfiguration>.Get().DalamudConfigurationSaved -= this.OnDalamudConfigurationSaved;
        this.uiBuilder.DisposeInternal();
    }

    /// <summary>
    /// Dispatch the active plugins changed event.
    /// </summary>
    /// <param name="kind">What action caused this event to be fired.</param>
    /// <param name="affectedThisPlugin">If this plugin was affected by the change.</param>
    internal void NotifyActivePluginsChanged(PluginListInvalidationKind kind, bool affectedThisPlugin)
    {
        if (this.ActivePluginsChanged is { } callback)
        {
            foreach (var action in callback.GetInvocationList().Cast<IDalamudPluginInterface.ActivePluginsChangedDelegate>())
            {
                try
                {
                    action(kind, affectedThisPlugin);
                }
                catch (Exception ex)
                {
                    Log.Error(ex, "Exception during raise of {handler}", action.Method);
                }
            }
        }
    }

    private void OnLocalizationChanged(string langCode)
    {
        this.UiLanguage = langCode;

        if (this.LanguageChanged is { } callback)
        {
            foreach (var action in callback.GetInvocationList().Cast<IDalamudPluginInterface.LanguageChangedDelegate>())
            {
                try
                {
                    action(langCode);
                }
                catch (Exception ex)
                {
                    Log.Error(ex, "Exception during raise of {handler}", action.Method);
                }
            }
        }
    }

    private void OnDalamudConfigurationSaved(DalamudConfiguration dalamudConfiguration)
    {
        this.GeneralChatType = dalamudConfiguration.GeneralChatType;
    }

    private object[] GetPublicIocScopes(IEnumerable<object> scopedObjects)
    {
        return scopedObjects.Append(this).ToArray();
    }
}
﻿using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Threading.Tasks;

using Dalamud.Configuration;
using Dalamud.Game.Text;
using Dalamud.Game.Text.Sanitizer;
using Dalamud.Game.Text.SeStringHandling;
using Dalamud.Game.Text.SeStringHandling.Payloads;
using Dalamud.Interface;
using Dalamud.Interface.Internal.Windows.PluginInstaller;
using Dalamud.Interface.Internal.Windows.Settings;
using Dalamud.Plugin.Internal.Types.Manifest;
using Dalamud.Plugin.Ipc;
using Dalamud.Plugin.Ipc.Exceptions;
using Dalamud.Plugin.Ipc.Internal;

namespace Dalamud.Plugin;

/// <summary>
/// This interface acts as an interface to various objects needed to interact with Dalamud and the game.
/// </summary>
public interface IDalamudPluginInterface
{
    /// <summary>
    /// Delegate for localization change with two-letter iso lang code.
    /// </summary>
    /// <param name="langCode">The new language code.</param>
    public delegate void LanguageChangedDelegate(string langCode);

    /// <summary>
    /// Delegate for events that listen to changes to the list of active plugins.
    /// </summary>
    /// <param name="kind">What action caused this event to be fired.</param>
    /// <param name="affectedThisPlugin">If this plugin was affected by the change.</param>
    public delegate void ActivePluginsChangedDelegate(PluginListInvalidationKind kind, bool affectedThisPlugin);
    
    /// <summary>
    /// Event that gets fired when loc is changed
    /// </summary>
    event LanguageChangedDelegate LanguageChanged;

    /// <summary>
    /// Event that is fired when the active list of plugins is changed.
    /// </summary>
    event ActivePluginsChangedDelegate ActivePluginsChanged;

    /// <summary>
    /// Gets the reason this plugin was loaded.
    /// </summary>
    PluginLoadReason Reason { get; }

    /// <summary>
    /// Gets a value indicating whether or not auto-updates have already completed this session.
    /// </summary>
    bool IsAutoUpdateComplete { get; }

    /// <summary>
    /// Gets the repository from which this plugin was installed.
    ///
    /// If a plugin was installed from the official/main repository, this will return the value of
    /// <see cref="SpecialPluginSource.MainRepo"/>. Developer plugins will return the value of
    /// <see cref="SpecialPluginSource.DevPlugin"/>.
    /// </summary>
    string SourceRepository { get; }

    /// <summary>
    /// Gets the current internal plugin name.
    /// </summary>
    string InternalName { get; }

    /// <summary>
    /// Gets the plugin's manifest.
    /// </summary>
    IPluginManifest Manifest { get; }

    /// <summary>
    /// Gets a value indicating whether this is a dev plugin.
    /// </summary>
    bool IsDev { get; }

    /// <summary>
    /// Gets a value indicating whether this is a testing release of a plugin.
    /// </summary>
    /// <remarks>
    /// Dev plugins have undefined behavior for this value, but can be expected to return <c>false</c>.
    /// </remarks>
    bool IsTesting { get; }

    /// <summary>
    /// Gets the time that this plugin was loaded.
    /// </summary>
    DateTime LoadTime { get; }

    /// <summary>
    /// Gets the UTC time that this plugin was loaded.
    /// </summary>
    DateTime LoadTimeUTC { get; }

    /// <summary>
    /// Gets the timespan delta from when this plugin was loaded.
    /// </summary>
    TimeSpan LoadTimeDelta { get; }

    /// <summary>
    /// Gets the directory Dalamud assets are stored in.
    /// </summary>
    DirectoryInfo DalamudAssetDirectory { get; }

    /// <summary>
    /// Gets the location of your plugin assembly.
    /// </summary>
    FileInfo AssemblyLocation { get; }

    /// <summary>
    /// Gets the directory your plugin configurations are stored in.
    /// </summary>
    DirectoryInfo ConfigDirectory { get; }

    /// <summary>
    /// Gets the config file of your plugin.
    /// </summary>
    FileInfo ConfigFile { get; }

    /// <summary>
    /// Gets the <see cref="UiBuilder"/> instance which allows you to draw UI into the game via ImGui draw calls.
    /// </summary>
    IUiBuilder UiBuilder { get; }

    /// <summary>
    /// Gets a value indicating whether Dalamud is running in Debug mode or the /xldev menu is open. This can occur on release builds.
    /// </summary>
    bool IsDevMenuOpen { get; }

    /// <summary>
    /// Gets a value indicating whether a debugger is attached.
    /// </summary>
    bool IsDebugging { get; }

    /// <summary>
    /// Gets the current UI language in two-letter iso format.
    /// </summary>
    string UiLanguage { get; }

    /// <summary>
    /// Gets serializer class with functions to remove special characters from strings.
    /// </summary>
    ISanitizer Sanitizer { get; }

    /// <summary>
    /// Gets the chat type used by default for plugin messages.
    /// </summary>
    XivChatType GeneralChatType { get; }

    /// <summary>
    /// Gets a list of installed plugins along with their current state.
    /// </summary>
    IEnumerable<IExposedPlugin> InstalledPlugins { get; }

    /// <summary>
    /// Opens the <see cref="PluginInstallerWindow"/>, with an optional search term.
    /// </summary>
    /// <param name="openTo">The page to open the installer to. Defaults to the "All Plugins" page.</param>
    /// <param name="searchText">An optional search text to input in the search box.</param>
    /// <returns>Returns false if the DalamudInterface was null.</returns>
    bool OpenPluginInstallerTo(PluginInstallerOpenKind openTo = PluginInstallerOpenKind.AllPlugins, string? searchText = null);

    /// <summary>
    /// Opens the <see cref="SettingsWindow"/>, with an optional search term.
    /// </summary>
    /// <param name="openTo">The tab to open the settings to. Defaults to the "General" tab.</param>
    /// <param name="searchText">An optional search text to input in the search box.</param>
    /// <returns>Returns false if the DalamudInterface was null.</returns>
    bool OpenDalamudSettingsTo(SettingsOpenKind openTo = SettingsOpenKind.General, string? searchText = null);

    /// <summary>
    /// Opens the dev menu bar.
    /// </summary>
    /// <returns>Returns false if the DalamudInterface was null.</returns>
    bool OpenDeveloperMenu();

    /// <inheritdoc cref="DataShare.GetOrCreateData{T}"/>
    T GetOrCreateData<T>(string tag, Func<T> dataGenerator) where T : class;

    /// <inheritdoc cref="DataShare.RelinquishData"/>
    void RelinquishData(string tag);

    /// <inheritdoc cref="DataShare.TryGetData{T}"/>
    bool TryGetData<T>(string tag, [NotNullWhen(true)] out T? data) where T : class;

    /// <inheritdoc cref="DataShare.GetData{T}"/>
    T? GetData<T>(string tag) where T : class;

    /// <summary>
    /// Gets an IPC provider.
    /// </summary>
    /// <typeparam name="TRet">The return type for funcs. Use object if this is unused.</typeparam>
    /// <param name="name">The name of the IPC registration.</param>
    /// <returns>An IPC provider.</returns>
    /// <exception cref="IpcTypeMismatchError">This is thrown when the requested types do not match the previously registered types are different.</exception>
    ICallGateProvider<TRet> GetIpcProvider<TRet>(string name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    ICallGateProvider<T1, TRet> GetIpcProvider<T1, TRet>(string name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    ICallGateProvider<T1, T2, TRet> GetIpcProvider<T1, T2, TRet>(string name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    ICallGateProvider<T1, T2, T3, TRet> GetIpcProvider<T1, T2, T3, TRet>(string name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    ICallGateProvider<T1, T2, T3, T4, TRet> GetIpcProvider<T1, T2, T3, T4, TRet>(string name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    ICallGateProvider<T1, T2, T3, T4, T5, TRet> GetIpcProvider<T1, T2, T3, T4, T5, TRet>(string name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    ICallGateProvider<T1, T2, T3, T4, T5, T6, TRet> GetIpcProvider<T1, T2, T3, T4, T5, T6, TRet>(string name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    ICallGateProvider<T1, T2, T3, T4, T5, T6, T7, TRet> GetIpcProvider<T1, T2, T3, T4, T5, T6, T7, TRet>(string name);

    /// <inheritdoc cref="ICallGateProvider{TRet}"/>
    ICallGateProvider<T1, T2, T3, T4, T5, T6, T7, T8, TRet> GetIpcProvider<T1, T2, T3, T4, T5, T6, T7, T8, TRet>(string name);

    /// <summary>
    /// Gets an IPC subscriber.
    /// </summary>
    /// <typeparam name="TRet">The return type for funcs. Use object if this is unused.</typeparam>
    /// <param name="name">The name of the IPC registration.</param>
    /// <returns>An IPC subscriber.</returns>
    ICallGateSubscriber<TRet> GetIpcSubscriber<TRet>(string name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    ICallGateSubscriber<T1, TRet> GetIpcSubscriber<T1, TRet>(string name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    ICallGateSubscriber<T1, T2, TRet> GetIpcSubscriber<T1, T2, TRet>(string name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    ICallGateSubscriber<T1, T2, T3, TRet> GetIpcSubscriber<T1, T2, T3, TRet>(string name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    ICallGateSubscriber<T1, T2, T3, T4, TRet> GetIpcSubscriber<T1, T2, T3, T4, TRet>(string name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    ICallGateSubscriber<T1, T2, T3, T4, T5, TRet> GetIpcSubscriber<T1, T2, T3, T4, T5, TRet>(string name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    ICallGateSubscriber<T1, T2, T3, T4, T5, T6, TRet> GetIpcSubscriber<T1, T2, T3, T4, T5, T6, TRet>(string name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    ICallGateSubscriber<T1, T2, T3, T4, T5, T6, T7, TRet> GetIpcSubscriber<T1, T2, T3, T4, T5, T6, T7, TRet>(string name);

    /// <inheritdoc cref="ICallGateSubscriber{TRet}"/>
    ICallGateSubscriber<T1, T2, T3, T4, T5, T6, T7, T8, TRet> GetIpcSubscriber<T1, T2, T3, T4, T5, T6, T7, T8, TRet>(string name);

    /// <summary>
    /// Save a plugin configuration(inheriting IPluginConfiguration).
    /// </summary>
    /// <param name="currentConfig">The current configuration.</param>
    void SavePluginConfig(IPluginConfiguration? currentConfig);

    /// <summary>
    /// Get a previously saved plugin configuration or null if none was saved before.
    /// </summary>
    /// <returns>A previously saved config or null if none was saved before.</returns>
    IPluginConfiguration? GetPluginConfig();

    /// <summary>
    /// Get the config directory.
    /// </summary>
    /// <returns>directory with path of AppData/XIVLauncher/pluginConfig/PluginInternalName.</returns>
    string GetPluginConfigDirectory();

    /// <summary>
    /// Get the loc directory.
    /// </summary>
    /// <returns>directory with path of AppData/XIVLauncher/pluginConfig/PluginInternalName/loc.</returns>
    string GetPluginLocDirectory();

    /// <summary>
    /// Register a chat link handler.
    /// </summary>
    /// <param name="commandId">The ID of the command.</param>
    /// <param name="commandAction">The action to be executed.</param>
    /// <returns>Returns an SeString payload for the link.</returns>
    DalamudLinkPayload AddChatLinkHandler(uint commandId, Action<uint, SeString> commandAction);

    /// <summary>
    /// Remove a chat link handler.
    /// </summary>
    /// <param name="commandId">The ID of the command.</param>
    void RemoveChatLinkHandler(uint commandId);

    /// <summary>
    /// Removes all chat link handlers registered by the plugin.
    /// </summary>
    void RemoveChatLinkHandler();

    /// <summary>
    /// Create a new object of the provided type using its default constructor, then inject objects and properties.
    /// </summary>
    /// <param name="scopedObjects">Objects to inject additionally.</param>
    /// <typeparam name="T">The type to create.</typeparam>
    /// <returns>The created and initialized type, or <c>null</c> on failure.</returns>
    T? Create<T>(params object[] scopedObjects) where T : class;

    /// <summary>
    /// Create a new object of the provided type using its default constructor, then inject objects and properties.
    /// </summary>
    /// <param name="scopedObjects">Objects to inject additionally.</param>
    /// <typeparam name="T">The type to create.</typeparam>
    /// <returns>A task representing the created and initialized type.</returns>
    Task<T> CreateAsync<T>(params object[] scopedObjects) where T : class;

    /// <summary>
    /// Inject services into properties on the provided object instance.
    /// </summary>
    /// <param name="instance">The instance to inject services into.</param>
    /// <param name="scopedObjects">Objects to inject additionally.</param>
    /// <returns>Whether the injection succeeded.</returns>
    bool Inject(object instance, params object[] scopedObjects);

    /// <summary>
    /// Inject services into properties on the provided object instance.
    /// </summary>
    /// <param name="instance">The instance to inject services into.</param>
    /// <param name="scopedObjects">Objects to inject additionally.</param>
    /// <returns>A <see cref="ValueTask"/> representing the status of the operation.</returns>
    Task InjectAsync(object instance, params object[] scopedObjects);
}﻿using Dalamud.Plugin.Internal.Types;

namespace Dalamud.Plugin;

/// <summary>
/// Interface representing an installed plugin, to be exposed to other plugins.
/// </summary>
public interface IExposedPlugin
{
    /// <summary>
    /// Gets the name of the plugin.
    /// </summary>
    string Name { get; }

    /// <summary>
    /// Gets the internal name of the plugin.
    /// </summary>
    string InternalName { get; }

    /// <summary>
    /// Gets a value indicating whether the plugin is loaded.
    /// </summary>
    bool IsLoaded { get; }

    /// <summary>
    /// Gets the version of the plugin.
    /// </summary>
    Version Version { get; }

    /// <summary>
    /// Gets a value indicating whether the plugin has a main UI.
    /// </summary>
    public bool HasMainUi { get; }

    /// <summary>
    /// Gets a value indicating whether the plugin has a config UI.
    /// </summary>
    public bool HasConfigUi { get; }

    /// <summary>
    /// Opens the main UI of the plugin.
    /// Throws <see cref="InvalidOperationException"/> if <see cref="HasMainUi"/> is false.
    /// </summary>
    public void OpenMainUi();

    /// <summary>
    /// Opens the config UI of the plugin.
    /// Throws <see cref="InvalidOperationException"/> if <see cref="HasConfigUi"/> is false.
    /// </summary>
    public void OpenConfigUi();
}

/// <summary>
/// Internal representation of an installed plugin, to be exposed to other plugins.
/// </summary>
/// <param name="plugin">The plugin.</param>
internal sealed class ExposedPlugin(LocalPlugin plugin) : IExposedPlugin
{
    /// <inheritdoc/>
    public string Name => plugin.Name;

    /// <inheritdoc/>
    public string InternalName => plugin.InternalName;

    /// <inheritdoc/>
    public bool IsLoaded => plugin.IsLoaded;

    /// <inheritdoc/>
    public Version Version => plugin.EffectiveVersion;

    /// <inheritdoc/>
    public bool HasMainUi => plugin.DalamudInterface?.LocalUiBuilder.HasMainUi ?? false;

    /// <inheritdoc/>
    public bool HasConfigUi => plugin.DalamudInterface?.LocalUiBuilder.HasConfigUi ?? false;

    /// <inheritdoc/>
    public void OpenMainUi()
    {
        if (plugin.DalamudInterface?.LocalUiBuilder.HasMainUi == true)
            plugin.DalamudInterface.LocalUiBuilder.OpenMain();
        else
            throw new InvalidOperationException("Plugin does not have a main UI.");
    }

    /// <inheritdoc/>
    public void OpenConfigUi()
    {
        if (plugin.DalamudInterface?.LocalUiBuilder.HasConfigUi == true)
            plugin.DalamudInterface.LocalUiBuilder.OpenConfig();
        else
            throw new InvalidOperationException("Plugin does not have a config UI.");
    }
}﻿namespace Dalamud.Plugin;

/// <summary>
/// Causes for a change to the plugin list.
/// </summary>
public enum PluginListInvalidationKind
{
    /// <summary>
    /// An installer-initiated update reloaded plugins.
    /// </summary>
    Update,

    /// <summary>
    /// An auto-update reloaded plugins.
    /// </summary>
    AutoUpdate,
}namespace Dalamud.Plugin;

/// <summary>
/// This enum reflects reasons for loading a plugin.
/// </summary>
public enum PluginLoadReason
{
    /// <summary>
    /// We don't know why this plugin was loaded.
    /// </summary>
    Unknown,

    /// <summary>
    /// This plugin was loaded because it was installed with the plugin installer.
    /// </summary>
    Installer,

    /// <summary>
    /// This plugin was loaded because it was just updated.
    /// </summary>
    Update,

    /// <summary>
    /// This plugin was loaded because it was told to reload.
    /// </summary>
    Reload,

    /// <summary>
    /// This plugin was loaded because the game was started or Dalamud was reinjected.
    /// </summary>
    Boot,
}

// TODO(api9): This should be a mask, so that we can combine Installer | ProfileLoaded
﻿using System.Collections.Generic;
using System.Runtime.InteropServices;

using Dalamud.Game.Addon.Lifecycle;
using Dalamud.Game.Addon.Lifecycle.AddonArgTypes;

namespace Dalamud.Plugin.Services;

/// <summary>
/// This class provides events for in-game addon lifecycles.
/// </summary>
public interface IAddonLifecycle
{
    /// <summary>
    /// Delegate for receiving addon lifecycle event messages.
    /// </summary>
    /// <param name="type">The event type that triggered the message.</param>
    /// <param name="args">Information about what addon triggered the message.</param>
    public delegate void AddonEventDelegate(AddonEvent type, AddonArgs args);
    
    /// <summary>
    /// Register a listener that will trigger on the specified event and any of the specified addons.
    /// </summary>
    /// <param name="eventType">Event type to trigger on.</param>
    /// <param name="addonNames">Addon names that will trigger the handler to be invoked.</param>
    /// <param name="handler">The handler to invoke.</param>
    void RegisterListener(AddonEvent eventType, IEnumerable<string> addonNames, AddonEventDelegate handler);
    
    /// <summary>
    /// Register a listener that will trigger on the specified event only for the specified addon.
    /// </summary>
    /// <param name="eventType">Event type to trigger on.</param>
    /// <param name="addonName">The addon name that will trigger the handler to be invoked.</param>
    /// <param name="handler">The handler to invoke.</param>
    void RegisterListener(AddonEvent eventType, string addonName, AddonEventDelegate handler);
    
    /// <summary>
    /// Register a listener that will trigger on the specified event for any addon.
    /// </summary>
    /// <param name="eventType">Event type to trigger on.</param>
    /// <param name="handler">The handler to invoke.</param>
    void RegisterListener(AddonEvent eventType, AddonEventDelegate handler);
    
    /// <summary>
    /// Unregister listener from specified event type and specified addon names.
    /// </summary>
    /// <remarks>
    /// If a specific handler is not provided, all handlers for the event type and addon names will be unregistered.
    /// </remarks>
    /// <param name="eventType">Event type to deregister.</param>
    /// <param name="addonNames">Addon names to deregister.</param>
    /// <param name="handler">Optional specific handler to remove.</param>
    void UnregisterListener(AddonEvent eventType, IEnumerable<string> addonNames, [Optional] AddonEventDelegate handler);
    
    /// <summary>
    /// Unregister all listeners for the specified event type and addon name.
    /// </summary>
    /// <remarks>
    /// If a specific handler is not provided, all handlers for the event type and addons will be unregistered.
    /// </remarks>
    /// <param name="eventType">Event type to deregister.</param>
    /// <param name="addonName">Addon name to deregister.</param>
    /// <param name="handler">Optional specific handler to remove.</param>
    void UnregisterListener(AddonEvent eventType, string addonName, [Optional] AddonEventDelegate handler);
    
    /// <summary>
    /// Unregister an event type handler.<br/>This will only remove a handler that is added via <see cref="RegisterListener(AddonEvent, AddonEventDelegate)"/>.
    /// </summary>
    /// <remarks>
    /// If a specific handler is not provided, all handlers for the event type and addons will be unregistered.
    /// </remarks>
    /// <param name="eventType">Event type to deregister.</param>
    /// <param name="handler">Optional specific handler to remove.</param>
    void UnregisterListener(AddonEvent eventType, [Optional] AddonEventDelegate handler);
    
    /// <summary>
    /// Unregister all events that use the specified handlers.
    /// </summary>
    /// <param name="handlers">Handlers to remove.</param>
    void UnregisterListener(params AddonEventDelegate[] handlers);
}using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;

using Dalamud.Common;
using Dalamud.Configuration.Internal;
using Dalamud.Game;
using Dalamud.Plugin.Internal;
using Dalamud.Storage;
using Dalamud.Utility;
using Dalamud.Utility.Timing;
using PInvoke;
using Serilog;

#if DEBUG
[assembly: InternalsVisibleTo("Dalamud.CorePlugin")]
#endif

[assembly: InternalsVisibleTo("Dalamud.Test")]
[assembly: InternalsVisibleTo("Dalamud.DevHelpers")]

namespace Dalamud;

/// <summary>
/// The main Dalamud class containing all subsystems.
/// </summary>
[ServiceManager.ProvidedService]
internal sealed class Dalamud : IServiceType
{
    #region Internals

    private static int shownServiceError = 0;
    private readonly ManualResetEvent unloadSignal;
    
    #endregion

    /// <summary>
    /// Initializes a new instance of the <see cref="Dalamud"/> class.
    /// </summary>
    /// <param name="info">DalamudStartInfo instance.</param>
    /// <param name="fs">ReliableFileStorage instance.</param>
    /// <param name="configuration">The Dalamud configuration.</param>
    /// <param name="mainThreadContinueEvent">Event used to signal the main thread to continue.</param>
    public Dalamud(DalamudStartInfo info, ReliableFileStorage fs, DalamudConfiguration configuration, IntPtr mainThreadContinueEvent)
    {
        this.StartInfo = info;
        
        this.unloadSignal = new ManualResetEvent(false);
        this.unloadSignal.Reset();
        
        // Directory resolved signatures(CS, our own) will be cached in
        var cacheDir = new DirectoryInfo(Path.Combine(this.StartInfo.WorkingDirectory!, "cachedSigs"));
        if (!cacheDir.Exists)
            cacheDir.Create();
        
        // Set up the SigScanner for our target module
        TargetSigScanner scanner;
        using (Timings.Start("SigScanner Init"))
        {
            scanner = new TargetSigScanner(
                true, new FileInfo(Path.Combine(cacheDir.FullName, $"{this.StartInfo.GameVersion}.json")));
        }

        ServiceManager.InitializeProvidedServices(
            this,
            fs,
            configuration,
            scanner,
            Localization.FromAssets(info.AssetDirectory!, configuration.LanguageOverride));
        
        // Set up FFXIVClientStructs
        this.SetupClientStructsResolver(cacheDir);
        
        void KickoffGameThread()
        {
            Log.Verbose("=============== GAME THREAD KICKOFF ===============");
            Timings.Event("Game thread kickoff");
            NativeFunctions.SetEvent(mainThreadContinueEvent);
        }

        void HandleServiceInitFailure(Task t)
        {
            Log.Error(t.Exception!, "Service initialization failure");
            
            if (Interlocked.CompareExchange(ref shownServiceError, 1, 0) != 0)
                return;

            Util.Fatal(
                "Dalamud failed to load all necessary services.\n\nThe game will continue, but you may not be able to use plugins.",
                "Dalamud", false);
        }

        ServiceManager.InitializeEarlyLoadableServices()
                      .ContinueWith(
                          t =>
                          {
                              if (t.IsCompletedSuccessfully)
                                  return;

                              HandleServiceInitFailure(t);
                          });

        ServiceManager.BlockingResolved.ContinueWith(
            t =>
            {
                if (t.IsCompletedSuccessfully)
                {
                    KickoffGameThread();
                    return;
                }

                HandleServiceInitFailure(t);
            });

        this.DefaultExceptionFilter = NativeFunctions.SetUnhandledExceptionFilter(nint.Zero);
        NativeFunctions.SetUnhandledExceptionFilter(this.DefaultExceptionFilter);
        Log.Debug($"SE default exception filter at {this.DefaultExceptionFilter.ToInt64():X}");

        var debugSig = "40 55 53 57 48 8D AC 24 70 AD FF FF";
        this.DebugExceptionFilter = Service<TargetSigScanner>.Get().ScanText(debugSig);
        Log.Debug($"SE debug exception filter at {this.DebugExceptionFilter.ToInt64():X}");
    }
    
    /// <summary>
    /// Gets the start information for this Dalamud instance.
    /// </summary>
    internal DalamudStartInfo StartInfo { get; private set; }

    /// <summary>
    /// Gets location of stored assets.
    /// </summary>
    internal DirectoryInfo AssetDirectory => new(this.StartInfo.AssetDirectory!);

    /// <summary>
    /// Gets the in-game default exception filter.
    /// </summary>
    private nint DefaultExceptionFilter { get; }

    /// <summary>
    /// Gets the in-game debug exception filter.
    /// </summary>
    private nint DebugExceptionFilter { get; }

    /// <summary>
    /// Signal to the crash handler process that we should restart the game.
    /// </summary>
    public static void RestartGame()
    {
        [DllImport("kernel32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern void RaiseException(uint dwExceptionCode, uint dwExceptionFlags, uint nNumberOfArguments, IntPtr lpArguments);

        RaiseException(0x12345678, 0, 0, IntPtr.Zero);
        Process.GetCurrentProcess().Kill();
    }

    /// <summary>
    /// Queue an unload of Dalamud when it gets the chance.
    /// </summary>
    public void Unload()
    {
        Log.Information("Trigger unload");

        var reportCrashesSetting = Service<DalamudConfiguration>.GetNullable()?.ReportShutdownCrashes ?? true;
        var pmHasDevPlugins = Service<PluginManager>.GetNullable()?.InstalledPlugins.Any(x => x.IsDev) ?? false;
        if (!reportCrashesSetting && !pmHasDevPlugins)
        {
            // Leaking on purpose for now
            var attribs = Kernel32.SECURITY_ATTRIBUTES.Create();
            Kernel32.CreateMutex(attribs, false, "DALAMUD_CRASHES_NO_MORE");
        }

        this.unloadSignal.Set();
    }

    /// <summary>
    /// Wait for an unload request to start.
    /// </summary>
    public void WaitForUnload()
    {
        this.unloadSignal.WaitOne();
    }

    /// <summary>
    /// Replace the current exception handler with the default one.
    /// </summary>
    internal void UseDefaultExceptionHandler() => 
        this.SetExceptionHandler(this.DefaultExceptionFilter);

    /// <summary>
    /// Replace the current exception handler with a debug one.
    /// </summary>
    internal void UseDebugExceptionHandler() =>
        this.SetExceptionHandler(this.DebugExceptionFilter);

    /// <summary>
    /// Disable the current exception handler.
    /// </summary>
    internal void UseNoExceptionHandler() =>
        this.SetExceptionHandler(nint.Zero);

    /// <summary>
    /// Helper function to set the exception handler.
    /// </summary>
    private void SetExceptionHandler(nint newFilter)
    {
        var oldFilter = NativeFunctions.SetUnhandledExceptionFilter(newFilter);
        Log.Debug("Set ExceptionFilter to {0}, old: {1}", newFilter, oldFilter);
    }

    private void SetupClientStructsResolver(DirectoryInfo cacheDir)
    {
        using (Timings.Start("CS Resolver Init"))
        {
            // the resolver tracks version as a field in the json
            InteropGenerator.Runtime.Resolver.GetInstance.Setup(Service<TargetSigScanner>.Get().SearchBase, $"{this.StartInfo.GameVersion}", new FileInfo(Path.Combine(cacheDir.FullName, "cs.json")));
            FFXIVClientStructs.Interop.Generated.Addresses.Register();
            InteropGenerator.Runtime.Resolver.GetInstance.Resolve();
        }
    }
}

﻿namespace WpfPluginSample.PluginFramework
{
    public interface IPluginController
    {
        void Initialize();

        object CreateMainView();
        
        void Shutdown();
    }
}

﻿using System;
using System.Collections.Generic;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Ipc;
using System.Runtime.Serialization.Formatters;

namespace WpfPluginSample.PluginFramework
{
    public static class RemoteServiceLocator
    {
        private static readonly object initializeIpcChannelLock = new object();


        public static TInterface GetService<TInterface>()
            where TInterface : class
        {
            string objectUri = "ipc://" + GetIpcPortName<TInterface>() + "/" + typeof(TInterface).FullName;
            return (TInterface)Activator.GetObject(typeof(TInterface), objectUri);
        }
        
        public static string GetIpcPortName<TInterface>()
            where TInterface : class
        {
            // TODO: Optional use the GUID attribute or introduce an own assembly attribute.
            return typeof(TInterface).Assembly.GetName().Name;
        }

        public static void RegisterType<TInterface, TImplementation>() 
            where TInterface : class
            where TImplementation : MarshalByRefObject, TInterface
        {
            RemotingConfiguration.RegisterWellKnownServiceType(typeof(TImplementation), typeof(TInterface).FullName, WellKnownObjectMode.Singleton);
        }

        public static void RegisterInstance<TInterface>(MarshalByRefObject instance)
            where TInterface : class
        {
            RemotingServices.Marshal(instance, typeof(TInterface).FullName);
        }

        // Call this only once for a process
        // ipcPortName is necessary if process provides services
        public static IpcChannel InitializeIpcChannel(string ipcPortName = null)
        {
            lock (initializeIpcChannelLock)
            {
                IpcChannel channel;
                if (string.IsNullOrEmpty(ipcPortName))
                {
                    // Only a client channel
                    channel = new IpcChannel();
                }
                else
                {
                    // Channel that supports server and client usage
                    var serverProvider = new BinaryServerFormatterSinkProvider { TypeFilterLevel = TypeFilterLevel.Full };
                    var clientProvider = new BinaryClientFormatterSinkProvider();
                    var properties = new Dictionary<string, string>();
                    properties["portName"] = ipcPortName;
                    channel = new IpcChannel(properties, clientProvider, serverProvider);
                }

                ChannelServices.RegisterChannel(channel, false);
                return channel;
            }
        }
    }
}
﻿using System.AddIn.Contract;
using System.Runtime.Remoting.Messaging;

namespace WpfPluginSample.PluginFramework.Internals
{
    public interface IPluginLoader
    {
        INativeHandleContract LoadPlugin(string assembly, string typeName);

        [OneWay]
        void Shutdown();
    }
}

﻿using System;
using System.AddIn.Contract;

namespace WpfPluginSample.PluginFramework.Internals
{
    public class NativeHandleContractInsulator : RemoteService, INativeHandleContract
    {
        private readonly INativeHandleContract source;

        public NativeHandleContractInsulator(INativeHandleContract source)
        {
            this.source = source;
        }

        public IntPtr GetHandle()
        {
            return source.GetHandle();
        }

        public int AcquireLifetimeToken()
        {
            return source.AcquireLifetimeToken();
        }

        public int GetRemoteHashCode()
        {
            return source.GetRemoteHashCode();
        }

        public IContract QueryContract(string contractIdentifier)
        {
            return source.QueryContract(contractIdentifier);
        }

        public bool RemoteEquals(IContract contract)
        {
            return source.RemoteEquals(contract);
        }

        public string RemoteToString()
        {
            return source.RemoteToString();
        }

        public void RevokeLifetimeToken(int token)
        {
            source.RevokeLifetimeToken(token);
        }
    }
}

﻿using System;
using System.Security;

namespace WpfPluginSample.PluginFramework.Internals
{
    /// <summary>
    /// Base class for singleton services which can be accessed over application domain boundaries via remoting.
    /// </summary>
    [Serializable]
    public abstract class RemoteService : MarshalByRefObject
    {
        [SecurityCritical]
        public override object InitializeLifetimeService()
        {
            return null;
        }
    }
}


﻿using System;

namespace WpfPluginSample.PluginFramework.Internals
{
    public class TypedArgs
    {
        public TypedArgs(int parentProcessId, string assemblyFile, string instanceName)
        {
            ParentProcessId = parentProcessId;
            AssemblyFile = assemblyFile;
            InstanceName = instanceName;
        }


        public int ParentProcessId { get; }

        public string AssemblyFile { get; }

        public string InstanceName { get; }


        public static TypedArgs FromArgs(string[] args)
        {
            int parentProcessId = Convert.ToInt32(args[0]);
            var assemblyFile = args[1];
            var name = args[2];
            return new TypedArgs(parentProcessId, assemblyFile, name);
        }

        public string ToArgs()
        {
            // Enclose the AssemblyFile within " chars because the path might contain spaces.
            return ParentProcessId + " \"" + AssemblyFile + "\" " + InstanceName;
        }
    }
}
