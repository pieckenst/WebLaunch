
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace DotNet.Plugin.Business
{
    public class PluginLoader
    {
        public static List<IPlugin> Plugins { get; set; }

        public void LoadPlugins()
        {
            Plugins = new List<IPlugin>();

            if(Directory.Exists(Constants.FolderName))
            {
                string[] files = Directory.GetFiles(Constants.FolderName);
                foreach (string file in files)
                {
                    if (file.EndsWith(".dll"))
                    {
                        Assembly.LoadFile(Path.GetFullPath(file));
                    }
                }
            }

            Type interfaceType = typeof(IPlugin);

            Type[] types = AppDomain.CurrentDomain.GetAssemblies()
                .SelectMany(a => a.GetTypes())
                .Where(p => interfaceType.IsAssignableFrom(p) && p.IsClass && !p.IsAbstract)
                .ToArray();

            foreach(Type type in types)
            {
                Plugins.Add((IPlugin)Activator.CreateInstance(type));
            }

			SortPlugins();
        }

		private void SortPlugins()
		{
			//Idea from: https://stackoverflow.com/questions/7099741/c-sharp-list-sort-by-two-columns
			Plugins = Plugins.OrderBy(a=>a.Category).ThenBy(a=>a.Name).ToList();
		}
    }
}
namespace DotNet.Plugin.Business
{
    public interface IPlugin
    {
        string Name { get; }
		string Category { get; }
        string Explanation { get; }
        void Go(string parameters);
    }
}
ï»¿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.Loader;
using McMaster.NETCore.Plugins.Internal;
using McMaster.NETCore.Plugins.Loader;

namespace McMaster.NETCore.Plugins
{
    /// <summary>
    /// This loader attempts to load binaries for execution (both managed assemblies and native libraries)
    /// in the same way that .NET Core would if they were originally part of the .NET Core application.
    /// <para>
    /// This loader reads configuration files produced by .NET Core (.deps.json and runtimeconfig.json)
    /// as well as a custom file (*.config files). These files describe a list of .dlls and a set of dependencies.
    /// The loader searches the plugin path, as well as any additionally specified paths, for binaries
    /// which satisfy the plugin's requirements.
    /// </para>
    /// </summary>
    public class PluginLoader : IDisposable
    {
#if FEATURE_UNLOAD
        /// <summary>
        /// Create a plugin loader for an assembly file.
        /// </summary>
        /// <param name="assemblyFile">The file path to the main assembly for the plugin.</param>
        /// <param name="isUnloadable">Enable unloading the plugin from memory.</param>
        /// <param name="sharedTypes">
        /// <para>
        /// A list of types which should be shared between the host and the plugin.
        /// </para>
        /// <para>
        /// <seealso href="https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md">
        /// https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md
        /// </seealso>
        /// </para>
        /// </param>
        /// <returns>A loader.</returns>
        public static PluginLoader CreateFromAssemblyFile(string assemblyFile, bool isUnloadable, Type[] sharedTypes)
            => CreateFromAssemblyFile(assemblyFile, isUnloadable, sharedTypes, _ => { });

        /// <summary>
        /// Create a plugin loader for an assembly file.
        /// </summary>
        /// <param name="assemblyFile">The file path to the main assembly for the plugin.</param>
        /// <param name="isUnloadable">Enable unloading the plugin from memory.</param>
        /// <param name="sharedTypes">
        /// <para>
        /// A list of types which should be shared between the host and the plugin.
        /// </para>
        /// <para>
        /// <seealso href="https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md">
        /// https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md
        /// </seealso>
        /// </para>
        /// </param>
        /// <param name="configure">A function which can be used to configure advanced options for the plugin loader.</param>
        /// <returns>A loader.</returns>
        public static PluginLoader CreateFromAssemblyFile(string assemblyFile, bool isUnloadable, Type[] sharedTypes, Action<PluginConfig> configure)
        {
            return CreateFromAssemblyFile(assemblyFile,
                    sharedTypes,
                    config =>
                    {
                        config.IsUnloadable = isUnloadable;
                        configure(config);
                    });
        }
#endif

        /// <summary>
        /// Create a plugin loader for an assembly file.
        /// </summary>
        /// <param name="assemblyFile">The file path to the main assembly for the plugin.</param>
        /// <param name="sharedTypes">
        /// <para>
        /// A list of types which should be shared between the host and the plugin.
        /// </para>
        /// <para>
        /// <seealso href="https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md">
        /// https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md
        /// </seealso>
        /// </para>
        /// </param>
        /// <returns>A loader.</returns>
        public static PluginLoader CreateFromAssemblyFile(string assemblyFile, Type[] sharedTypes)
            => CreateFromAssemblyFile(assemblyFile, sharedTypes, _ => { });

        /// <summary>
        /// Create a plugin loader for an assembly file.
        /// </summary>
        /// <param name="assemblyFile">The file path to the main assembly for the plugin.</param>
        /// <param name="sharedTypes">
        /// <para>
        /// A list of types which should be shared between the host and the plugin.
        /// </para>
        /// <para>
        /// <seealso href="https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md">
        /// https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md
        /// </seealso>
        /// </para>
        /// </param>
        /// <param name="configure">A function which can be used to configure advanced options for the plugin loader.</param>
        /// <returns>A loader.</returns>
        public static PluginLoader CreateFromAssemblyFile(string assemblyFile, Type[] sharedTypes, Action<PluginConfig> configure)
        {
            return CreateFromAssemblyFile(assemblyFile,
                    config =>
                    {
                        if (sharedTypes != null)
                        {
                            var uniqueAssemblies = new HashSet<Assembly>();
                            foreach (var type in sharedTypes)
                            {
                                uniqueAssemblies.Add(type.Assembly);
                            }

                            foreach (var assembly in uniqueAssemblies)
                            {
                                config.SharedAssemblies.Add(assembly.GetName());
                            }
                        }
                        configure(config);
                    });
        }

        /// <summary>
        /// Create a plugin loader for an assembly file.
        /// </summary>
        /// <param name="assemblyFile">The file path to the main assembly for the plugin.</param>
        /// <returns>A loader.</returns>
        public static PluginLoader CreateFromAssemblyFile(string assemblyFile)
            => CreateFromAssemblyFile(assemblyFile, _ => { });

        /// <summary>
        /// Create a plugin loader for an assembly file.
        /// </summary>
        /// <param name="assemblyFile">The file path to the main assembly for the plugin.</param>
        /// <param name="configure">A function which can be used to configure advanced options for the plugin loader.</param>
        /// <returns>A loader.</returns>
        public static PluginLoader CreateFromAssemblyFile(string assemblyFile, Action<PluginConfig> configure)
        {
            if (configure == null)
            {
                throw new ArgumentNullException(nameof(configure));
            }

            var config = new PluginConfig(assemblyFile);
            configure(config);
            return new PluginLoader(config);
        }

        private readonly PluginConfig _config;
        private ManagedLoadContext _context;
        private readonly AssemblyLoadContextBuilder _contextBuilder;
        private volatile bool _disposed;

#if FEATURE_UNLOAD
        private FileSystemWatcher? _fileWatcher;
        private Debouncer? _debouncer;
#endif

        /// <summary>
        /// Initialize an instance of <see cref="PluginLoader" />
        /// </summary>
        /// <param name="config">The configuration for the plugin.</param>
        public PluginLoader(PluginConfig config)
        {
            _config = config ?? throw new ArgumentNullException(nameof(config));
            _contextBuilder = CreateLoadContextBuilder(config);
            _context = (ManagedLoadContext)_contextBuilder.Build();
#if FEATURE_UNLOAD
            if (config.EnableHotReload)
            {
                StartFileWatcher();
            }
#endif
        }

        /// <summary>
        /// True when this plugin is capable of being unloaded.
        /// </summary>
        public bool IsUnloadable
        {
            get
            {
#if FEATURE_UNLOAD
                return _context.IsCollectible;
#else
                return false;
#endif
            }
        }

#if FEATURE_UNLOAD

        /// <summary>
        /// This event is raised when the plugin has been reloaded.
        /// If <see cref="PluginConfig.EnableHotReload" /> was set to <c>true</c>,
        /// the plugin will be reloaded when files on disk are changed.
        /// </summary>
        public event PluginReloadedEventHandler? Reloaded;

        /// <summary>
        /// The unloads and reloads the plugin assemblies.
        /// This method throws if <see cref="IsUnloadable" /> is <c>false</c>.
        /// </summary>
        public void Reload()
        {
            EnsureNotDisposed();

            if (!IsUnloadable)
            {
                throw new InvalidOperationException("Reload cannot be used because IsUnloadable is false");
            }

            _context.Unload();
            _context = (ManagedLoadContext)_contextBuilder.Build();
            GC.Collect();
            GC.WaitForPendingFinalizers();
            Reloaded?.Invoke(this, new PluginReloadedEventArgs(this));
        }

        private void StartFileWatcher()
        {
            /*
            This is a very simple implementation.
            Some improvements that could be made in the future:

                * Watch all directories which contain assemblies that could be loaded
                * Support a polling file watcher.
                * Handle delete/recreate better.

            If you're interested in making improvements, feel free to send a pull request.
            */

            _debouncer = new Debouncer(_config.ReloadDelay);

            _fileWatcher = new FileSystemWatcher
            {
                Path = Path.GetDirectoryName(_config.MainAssemblyPath)
            };
            _fileWatcher.Changed += OnFileChanged;
            _fileWatcher.Filter = "*.dll";
            _fileWatcher.NotifyFilter = NotifyFilters.LastWrite;
            _fileWatcher.EnableRaisingEvents = true;
        }

        private void OnFileChanged(object source, FileSystemEventArgs e)
        {
            if (!_disposed)
            {
                _debouncer?.Execute(Reload);
            }
        }
#endif

        internal AssemblyLoadContext LoadContext => _context;

        /// <summary>
        /// Load the main assembly for the plugin.
        /// </summary>
        public Assembly LoadDefaultAssembly()
        {
            EnsureNotDisposed();
            return _context.LoadAssemblyFromFilePath(_config.MainAssemblyPath);
        }

        /// <summary>
        /// Load an assembly by name.
        /// </summary>
        /// <param name="assemblyName">The assembly name.</param>
        /// <returns>The assembly.</returns>
        public Assembly LoadAssembly(AssemblyName assemblyName)
        {
            EnsureNotDisposed();
            return _context.LoadFromAssemblyName(assemblyName);
        }

        /// <summary>
        /// Load an assembly from path.
        /// </summary>
        /// <param name="assemblyPath">The assembly path.</param>
        /// <returns>The assembly.</returns>
        public Assembly LoadAssemblyFromPath(string assemblyPath)
            => _context.LoadAssemblyFromFilePath(assemblyPath);

        /// <summary>
        /// Load an assembly by name.
        /// </summary>
        /// <param name="assemblyName">The assembly name.</param>
        /// <returns>The assembly.</returns>
        public Assembly LoadAssembly(string assemblyName)
        {
            EnsureNotDisposed();
            return LoadAssembly(new AssemblyName(assemblyName));
        }

#if !NETCOREAPP2_1
        /// <summary>
        /// Sets the scope used by some System.Reflection APIs which might trigger assembly loading.
        /// <para>
        /// See https://github.com/dotnet/coreclr/blob/v3.0.0/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md for more details.
        /// </para>
        /// </summary>
        /// <returns></returns>
        public AssemblyLoadContext.ContextualReflectionScope EnterContextualReflection()
            => _context.EnterContextualReflection();
#endif

        /// <summary>
        /// Disposes the plugin loader. This only does something if <see cref="IsUnloadable" /> is true.
        /// When true, this will unload assemblies which which were loaded during the lifetime
        /// of the plugin.
        /// </summary>
        public void Dispose()
        {
            if (_disposed)
            {
                return;
            }

            _disposed = true;

#if FEATURE_UNLOAD
            if (_fileWatcher != null)
            {
                _fileWatcher.EnableRaisingEvents = false;
                _fileWatcher.Changed -= OnFileChanged;
                _fileWatcher.Dispose();
            }

            _debouncer?.Dispose();

            if (_context.IsCollectible)
            {
                _context.Unload();
            }
#endif
        }

        private void EnsureNotDisposed()
        {
            if (_disposed)
            {
                throw new ObjectDisposedException(nameof(PluginLoader));
            }
        }

        private static AssemblyLoadContextBuilder CreateLoadContextBuilder(PluginConfig config)
        {
            var builder = new AssemblyLoadContextBuilder();

            builder.SetMainAssemblyPath(config.MainAssemblyPath);
            builder.SetDefaultContext(config.DefaultContext);

            foreach (var ext in config.PrivateAssemblies)
            {
                builder.PreferLoadContextAssembly(ext);
            }

            if (config.PreferSharedTypes)
            {
                builder.PreferDefaultLoadContext(true);
            }

#if FEATURE_UNLOAD
            if (config.IsUnloadable || config.EnableHotReload)
            {
                builder.EnableUnloading();
            }

            if (config.LoadInMemory)
            {
                builder.PreloadAssembliesIntoMemory();
                builder.ShadowCopyNativeLibraries();
            }
#endif

            builder.IsLazyLoaded(config.IsLazyLoaded);
            foreach (var assemblyName in config.SharedAssemblies)
            {
                builder.PreferDefaultLoadContextAssembly(assemblyName);
            }

#if !FEATURE_NATIVE_RESOLVER

            // In .NET Core 3.0, this code is unnecessary because the API, AssemblyDependencyResolver, handles parsing these files.
            var baseDir = Path.GetDirectoryName(config.MainAssemblyPath);
            var assemblyFileName = Path.GetFileNameWithoutExtension(config.MainAssemblyPath);

            var depsJsonFile = Path.Combine(baseDir, assemblyFileName + ".deps.json");
            if (File.Exists(depsJsonFile))
            {
                builder.AddDependencyContext(depsJsonFile);
            }

            var pluginRuntimeConfigFile = Path.Combine(baseDir, assemblyFileName + ".runtimeconfig.json");

            builder.TryAddAdditionalProbingPathFromRuntimeConfig(pluginRuntimeConfigFile, includeDevConfig: true, out _);

            // Always include runtimeconfig.json from the host app.
            // in some cases, like `dotnet test`, the entry assembly does not actually match with the
            // runtime config file which is why we search for all files matching this extensions.
            foreach (var runtimeconfig in Directory.GetFiles(AppContext.BaseDirectory, "*.runtimeconfig.json"))
            {
                builder.TryAddAdditionalProbingPathFromRuntimeConfig(runtimeconfig, includeDevConfig: true, out _);
            }
#endif

            return builder;
        }
    }
}

ï»¿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Loader;
using McMaster.NETCore.Plugins.LibraryModel;

namespace McMaster.NETCore.Plugins.Loader
{
    /// <summary>
    /// A builder for creating an instance of <see cref="AssemblyLoadContext" />.
    /// </summary>
    public class AssemblyLoadContextBuilder
    {
        private readonly List<string> _additionalProbingPaths = new();
        private readonly List<string> _resourceProbingPaths = new();
        private readonly List<string> _resourceProbingSubpaths = new();
        private readonly Dictionary<string, ManagedLibrary> _managedLibraries = new(StringComparer.Ordinal);
        private readonly Dictionary<string, NativeLibrary> _nativeLibraries = new(StringComparer.Ordinal);
        private readonly HashSet<string> _privateAssemblies = new(StringComparer.Ordinal);
        private readonly HashSet<string> _defaultAssemblies = new(StringComparer.Ordinal);
        private AssemblyLoadContext _defaultLoadContext = AssemblyLoadContext.GetLoadContext(Assembly.GetExecutingAssembly()) ?? AssemblyLoadContext.Default;
        private string? _mainAssemblyPath;
        private bool _preferDefaultLoadContext;
        private bool _lazyLoadReferences;

#if FEATURE_UNLOAD
        private bool _isCollectible;
        private bool _loadInMemory;
        private bool _shadowCopyNativeLibraries;
#endif

        /// <summary>
        /// Creates an assembly load context using settings specified on the builder.
        /// </summary>
        /// <returns>A new ManagedLoadContext.</returns>
        public AssemblyLoadContext Build()
        {
            var resourceProbingPaths = new List<string>(_resourceProbingPaths);
            foreach (var additionalPath in _additionalProbingPaths)
            {
                foreach (var subPath in _resourceProbingSubpaths)
                {
                    resourceProbingPaths.Add(Path.Combine(additionalPath, subPath));
                }
            }

            if (_mainAssemblyPath == null)
            {
                throw new InvalidOperationException($"Missing required property. You must call '{nameof(SetMainAssemblyPath)}' to configure the default assembly.");
            }

            return new ManagedLoadContext(
                _mainAssemblyPath,
                _managedLibraries,
                _nativeLibraries,
                _privateAssemblies,
                _defaultAssemblies,
                _additionalProbingPaths,
                resourceProbingPaths,
                _defaultLoadContext,
                _preferDefaultLoadContext,
                _lazyLoadReferences,
#if FEATURE_UNLOAD
                _isCollectible,
                _loadInMemory,
                _shadowCopyNativeLibraries);
#else
                isCollectible: false,
                loadInMemory: false,
                shadowCopyNativeLibraries: false);
#endif
        }

        /// <summary>
        /// Set the file path to the main assembly for the context. This is used as the starting point for loading
        /// other assemblies. The directory that contains it is also known as the 'app local' directory.
        /// </summary>
        /// <param name="path">The file path. Must not be null or empty. Must be an absolute path.</param>
        /// <returns>The builder.</returns>
        public AssemblyLoadContextBuilder SetMainAssemblyPath(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException("Argument must not be null or empty.", nameof(path));
            }

            if (!Path.IsPathRooted(path))
            {
                throw new ArgumentException("Argument must be a full path.", nameof(path));
            }

            _mainAssemblyPath = path;
            return this;
        }

        /// <summary>
        /// Replaces the default <see cref="AssemblyLoadContext"/> used by the <see cref="AssemblyLoadContextBuilder"/>.
        /// Use this feature if the <see cref="AssemblyLoadContext"/> of the <see cref="Assembly"/> is not the Runtime's default load context.
        /// i.e. (AssemblyLoadContext.GetLoadContext(Assembly.GetExecutingAssembly) != <see cref="AssemblyLoadContext.Default"/>
        /// </summary>
        /// <param name="context">The context to set.</param>
        /// <returns>The builder.</returns>
        public AssemblyLoadContextBuilder SetDefaultContext(AssemblyLoadContext context)
        {
            _defaultLoadContext = context ?? throw new ArgumentException($"Bad Argument: AssemblyLoadContext in {nameof(AssemblyLoadContextBuilder)}.{nameof(SetDefaultContext)} is null.");
            return this;
        }

        /// <summary>
        /// Instructs the load context to prefer a private version of this assembly, even if that version is
        /// different from the version used by the host application.
        /// Use this when you do not need to exchange types created from within the load context with other contexts
        /// or the default app context.
        /// <para>
        /// This may mean the types loaded from
        /// this assembly will not match the types from an assembly with the same name, but different version,
        /// in the host application.
        /// </para>
        /// <para>
        /// For example, if the host application has a type named <c>Foo</c> from assembly <c>Banana, Version=1.0.0.0</c>
        /// and the load context prefers a private version of <c>Banan, Version=2.0.0.0</c>, when comparing two objects,
        /// one created by the host (Foo1) and one created from within the load context (Foo2), they will not have the same
        /// type. <c>Foo1.GetType() != Foo2.GetType()</c>
        /// </para>
        /// </summary>
        /// <param name="assemblyName">The name of the assembly.</param>
        /// <returns>The builder.</returns>
        public AssemblyLoadContextBuilder PreferLoadContextAssembly(AssemblyName assemblyName)
        {
            if (assemblyName.Name != null)
            {
                _privateAssemblies.Add(assemblyName.Name);
            }

            return this;
        }

        /// <summary>
        /// Instructs the load context to first attempt to load assemblies by this name from the default app context, even
        /// if other assemblies in this load context express a dependency on a higher or lower version.
        /// Use this when you need to exchange types created from within the load context with other contexts
        /// or the default app context.
        /// </summary>
        /// <param name="assemblyName">The name of the assembly.</param>
        /// <returns>The builder.</returns>
        public AssemblyLoadContextBuilder PreferDefaultLoadContextAssembly(AssemblyName assemblyName)
        {
            // Lazy loaded references have dependencies resolved as they are loaded inside the actual Load Context.
            if (_lazyLoadReferences)
            {
                if (assemblyName.Name != null && !_defaultAssemblies.Contains(assemblyName.Name))
                {
                    _defaultAssemblies.Add(assemblyName.Name);
                    var assembly = _defaultLoadContext.LoadFromAssemblyName(assemblyName);
                    foreach (var reference in assembly.GetReferencedAssemblies())
                    {
                        if (reference.Name != null)
                        {
                            _defaultAssemblies.Add(reference.Name);
                        }
                    }
                }

                return this;
            }

            var names = new Queue<AssemblyName>();
            names.Enqueue(assemblyName);
            while (names.TryDequeue(out var name))
            {
                if (name.Name == null || _defaultAssemblies.Contains(name.Name))
                {
                    // base cases
                    continue;
                }

                _defaultAssemblies.Add(name.Name);

                // Load and find all dependencies of default assemblies.
                // This sacrifices some performance for determinism in how transitive
                // dependencies will be shared between host and plugin.
                var assembly = _defaultLoadContext.LoadFromAssemblyName(name);

                foreach (var reference in assembly.GetReferencedAssemblies())
                {
                    names.Enqueue(reference);
                }
            }

            return this;
        }

        /// <summary>
        /// Instructs the load context to first search for binaries from the default app context, even
        /// if other assemblies in this load context express a dependency on a higher or lower version.
        /// Use this when you need to exchange types created from within the load context with other contexts
        /// or the default app context.
        /// <para>
        /// This may mean the types loaded from within the context are force-downgraded to the version provided
        /// by the host. <seealso cref="PreferLoadContextAssembly" /> can be used to selectively identify binaries
        /// which should not be loaded from the default load context.
        /// </para>
        /// </summary>
        /// <param name="preferDefaultLoadContext">When true, first attemp to load binaries from the default load context.</param>
        /// <returns>The builder.</returns>
        public AssemblyLoadContextBuilder PreferDefaultLoadContext(bool preferDefaultLoadContext)
        {
            _preferDefaultLoadContext = preferDefaultLoadContext;
            return this;
        }

        /// <summary>
        /// Instructs the load context to lazy load dependencies of all shared assemblies.
        /// Reduces plugin load time at the expense of non-determinism in how transitive dependencies are loaded
        /// between the plugin and the host.
        ///
        /// Please be aware of the danger of using this option:
        /// <seealso href="https://github.com/natemcmaster/DotNetCorePlugins/pull/164#issuecomment-751557873">
        /// https://github.com/natemcmaster/DotNetCorePlugins/pull/164#issuecomment-751557873
        /// </seealso>
        /// </summary>
        /// <param name="isLazyLoaded">True to lazy load, else false.</param>
        /// <returns>The builder.</returns>
        public AssemblyLoadContextBuilder IsLazyLoaded(bool isLazyLoaded)
        {
            _lazyLoadReferences = isLazyLoaded;
            return this;
        }

        /// <summary>
        /// Add a managed library to the load context.
        /// </summary>
        /// <param name="library">The managed library.</param>
        /// <returns>The builder.</returns>
        public AssemblyLoadContextBuilder AddManagedLibrary(ManagedLibrary library)
        {
            ValidateRelativePath(library.AdditionalProbingPath);

            if (library.Name.Name != null)
            {
                _managedLibraries.Add(library.Name.Name, library);
            }

            return this;
        }

        /// <summary>
        /// Add a native library to the load context.
        /// </summary>
        /// <param name="library"></param>
        /// <returns></returns>
        public AssemblyLoadContextBuilder AddNativeLibrary(NativeLibrary library)
        {
            ValidateRelativePath(library.AppLocalPath);
            ValidateRelativePath(library.AdditionalProbingPath);

            _nativeLibraries.Add(library.Name, library);
            return this;
        }

        /// <summary>
        /// Add a <paramref name="path"/> that should be used to search for native and managed libraries.
        /// </summary>
        /// <param name="path">The file path. Must be a full file path.</param>
        /// <returns>The builder</returns>
        public AssemblyLoadContextBuilder AddProbingPath(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException("Value must not be null or empty.", nameof(path));
            }

            if (!Path.IsPathRooted(path))
            {
                throw new ArgumentException("Argument must be a full path.", nameof(path));
            }

            _additionalProbingPaths.Add(path);
            return this;
        }

        /// <summary>
        /// Add a <paramref name="path"/> that should be use to search for resource assemblies (aka satellite assemblies).
        /// </summary>
        /// <param name="path">The file path. Must be a full file path.</param>
        /// <returns>The builder</returns>
        public AssemblyLoadContextBuilder AddResourceProbingPath(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException("Value must not be null or empty.", nameof(path));
            }

            if (!Path.IsPathRooted(path))
            {
                throw new ArgumentException("Argument must be a full path.", nameof(path));
            }

            _resourceProbingPaths.Add(path);
            return this;
        }

#if FEATURE_UNLOAD
        /// <summary>
        /// Enable unloading the assembly load context.
        /// </summary>
        /// <returns>The builder</returns>
        public AssemblyLoadContextBuilder EnableUnloading()
        {
            _isCollectible = true;
            return this;
        }

        /// <summary>
        /// Read .dll files into memory to avoid locking the files.
        /// This is not as efficient, so is not enabled by default, but is required for scenarios
        /// like hot reloading.
        /// </summary>
        /// <returns>The builder</returns>
        public AssemblyLoadContextBuilder PreloadAssembliesIntoMemory()
        {
            _loadInMemory = true; // required to prevent dotnet from locking loaded files
            return this;
        }

        /// <summary>
        /// Shadow copy native libraries (unmanaged DLLs) to avoid locking of these files.
        /// This is not as efficient, so is not enabled by default, but is required for scenarios
        /// like hot reloading of plugins dependent on native libraries.
        /// </summary>
        /// <returns>The builder</returns>
        public AssemblyLoadContextBuilder ShadowCopyNativeLibraries()
        {
            _shadowCopyNativeLibraries = true;
            return this;
        }
#endif

        /// <summary>
        /// Add a <paramref name="path"/> that should be use to search for resource assemblies (aka satellite assemblies)
        /// relative to any paths specified as <see cref="AddProbingPath"/>
        /// </summary>
        /// <param name="path">The file path. Must not be a full file path since it will be appended to additional probing path roots.</param>
        /// <returns>The builder</returns>
        internal AssemblyLoadContextBuilder AddResourceProbingSubpath(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException("Value must not be null or empty.", nameof(path));
            }

            if (Path.IsPathRooted(path))
            {
                throw new ArgumentException("Argument must be not a full path.", nameof(path));
            }

            _resourceProbingSubpaths.Add(path);
            return this;
        }

        private static void ValidateRelativePath(string probingPath)
        {
            if (string.IsNullOrEmpty(probingPath))
            {
                throw new ArgumentException("Value must not be null or empty.", nameof(probingPath));
            }

            if (Path.IsPathRooted(probingPath))
            {
                throw new ArgumentException("Argument must be a relative path.", nameof(probingPath));
            }
        }
    }
}// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using McMaster.NETCore.Plugins.LibraryModel;
using Microsoft.Extensions.DependencyModel;
using NativeLibrary = McMaster.NETCore.Plugins.LibraryModel.NativeLibrary;

namespace McMaster.NETCore.Plugins.Loader
{
    /// <summary>
    /// Extensions for configuring a load context using .deps.json files.
    /// </summary>
    public static class DependencyContextExtensions
    {
        /// <summary>
        /// Add dependency information to a load context from a .deps.json file.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="depsFilePath">The full path to the .deps.json file.</param>
        /// <param name="error">An error, if one occurs while reading .deps.json</param>
        /// <returns>The builder.</returns>
        public static AssemblyLoadContextBuilder TryAddDependencyContext(this AssemblyLoadContextBuilder builder, string depsFilePath, out Exception? error)
        {
            error = null;
            try
            {
                builder.AddDependencyContext(depsFilePath);
            }
            catch (Exception ex)
            {
                error = ex;
            }

            return builder;
        }

        /// <summary>
        /// Add dependency information to a load context from a .deps.json file.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="depsFilePath">The full path to the .deps.json file.</param>
        /// <returns>The builder.</returns>
        public static AssemblyLoadContextBuilder AddDependencyContext(this AssemblyLoadContextBuilder builder, string depsFilePath)
        {

            var reader = new DependencyContextJsonReader();
            using (var file = File.OpenRead(depsFilePath))
            {
                var deps = reader.Read(file);
                builder.AddDependencyContext(deps);
            }

            return builder;
        }

        private static string GetFallbackRid()
        {
            // see https://github.com/dotnet/core-setup/blob/b64f7fffbd14a3517186b9a9d5cc001ab6e5bde6/src/corehost/common/pal.h#L53-L73

            string ridBase;

            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                ridBase = "win10";
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                ridBase = "linux";

            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                ridBase = "osx.10.12";
            }
            else
            {
                return "any";
            }

            return RuntimeInformation.OSArchitecture switch
            {
                Architecture.X86 => ridBase + "-x86",
                Architecture.X64 => ridBase + "-x64",
                Architecture.Arm => ridBase + "-arm",
                Architecture.Arm64 => ridBase + "-arm64",
                _ => ridBase,
            };
        }

        /// <summary>
        /// Add a pre-parsed <see cref="DependencyContext" /> to the load context.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="dependencyContext">The dependency context.</param>
        /// <returns>The builder.</returns>
        public static AssemblyLoadContextBuilder AddDependencyContext(this AssemblyLoadContextBuilder builder, DependencyContext dependencyContext)
        {
            var ridGraph = dependencyContext.RuntimeGraph.Any() || DependencyContext.Default == null
               ? dependencyContext.RuntimeGraph
               : DependencyContext.Default.RuntimeGraph;

            var rid = Microsoft.DotNet.PlatformAbstractions.RuntimeEnvironment.GetRuntimeIdentifier();
            var fallbackRid = GetFallbackRid();
            var fallbackGraph = ridGraph.FirstOrDefault(g => g.Runtime == rid)
                ?? ridGraph.FirstOrDefault(g => g.Runtime == fallbackRid)
                ?? new RuntimeFallbacks("any");

            foreach (var managed in dependencyContext.ResolveRuntimeAssemblies(fallbackGraph))
            {
                builder.AddManagedLibrary(managed);
            }

            foreach (var library in dependencyContext.ResolveResourceAssemblies())
            {
                foreach (var resource in library.ResourceAssemblies)
                {
                    /*
                     * For resource assemblies, look in $packageRoot/$packageId/$version/$resourceGrandparent
                     *
                     * For example, a deps file may contain
                     *
                     * "Example/1.0.0": {
                     *    "runtime": {
                     *         "lib/netcoreapp2.0/Example.dll": { }
                     *     },
                     *     "resources": {
                     *         "lib/netcoreapp2.0/es/Example.resources.dll": {
                     *           "locale": "es"
                     *         }
                     *     }
                     * }
                     *
                     * In this case, probing should happen in $packageRoot/example/1.0.0/lib/netcoreapp2.0
                     */

                    var resourceDir = Path.GetDirectoryName(Path.GetDirectoryName(resource.Path));

                    if (resourceDir != null)
                    {
                        var path = Path.Combine(library.Name.ToLowerInvariant(),
                            library.Version,
                            resourceDir);

                        builder.AddResourceProbingSubpath(path);
                    }
                }
            }

            foreach (var native in dependencyContext.ResolveNativeAssets(fallbackGraph))
            {
                builder.AddNativeLibrary(native);
            }

            return builder;
        }

        private static IEnumerable<ManagedLibrary> ResolveRuntimeAssemblies(this DependencyContext depContext, RuntimeFallbacks runtimeGraph)
        {
            var rids = GetRids(runtimeGraph);
            return from library in depContext.RuntimeLibraries
                   from assetPath in SelectAssets(rids, library.RuntimeAssemblyGroups)
                   select ManagedLibrary.CreateFromPackage(library.Name, library.Version, assetPath);
        }

        private static IEnumerable<RuntimeLibrary> ResolveResourceAssemblies(this DependencyContext depContext)
        {
            return from library in depContext.RuntimeLibraries
                   where library.ResourceAssemblies != null && library.ResourceAssemblies.Count > 0
                   select library;
        }

        private static IEnumerable<NativeLibrary> ResolveNativeAssets(this DependencyContext depContext, RuntimeFallbacks runtimeGraph)
        {
            var rids = GetRids(runtimeGraph);
            return from library in depContext.RuntimeLibraries
                   from assetPath in SelectAssets(rids, library.NativeLibraryGroups)
                       // some packages include symbols alongside native assets, such as System.Native.a or pwshplugin.pdb
                   where PlatformInformation.NativeLibraryExtensions.Contains(Path.GetExtension(assetPath), StringComparer.OrdinalIgnoreCase)
                   select NativeLibrary.CreateFromPackage(library.Name, library.Version, assetPath);
        }

        private static IEnumerable<string> GetRids(RuntimeFallbacks runtimeGraph)
        {
            return new[] { runtimeGraph.Runtime }.Concat(runtimeGraph?.Fallbacks ?? Enumerable.Empty<string>());
        }

        private static IEnumerable<string> SelectAssets(IEnumerable<string> rids, IEnumerable<RuntimeAssetGroup> groups)
        {
            foreach (var rid in rids)
            {
                var group = groups.FirstOrDefault(g => g.Runtime == rid);
                if (group != null)
                {
                    return group.AssetPaths;
                }
            }

            // Return the RID-agnostic group
            return groups.GetDefaultAssets();
        }
    }
}ï»¿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Loader;
using McMaster.NETCore.Plugins.LibraryModel;

namespace McMaster.NETCore.Plugins.Loader
{
    /// <summary>
    /// An implementation of <see cref="AssemblyLoadContext" /> which attempts to load managed and native
    /// binaries at runtime immitating some of the behaviors of corehost.
    /// </summary>
    [DebuggerDisplay("'{Name}' ({_mainAssemblyPath})")]
    internal class ManagedLoadContext : AssemblyLoadContext
    {
        private readonly string _basePath;
        private readonly string _mainAssemblyPath;
        private readonly IReadOnlyDictionary<string, ManagedLibrary> _managedAssemblies;
        private readonly IReadOnlyDictionary<string, NativeLibrary> _nativeLibraries;
        private readonly IReadOnlyCollection<string> _privateAssemblies;
        private readonly ICollection<string> _defaultAssemblies;
        private readonly IReadOnlyCollection<string> _additionalProbingPaths;
        private readonly bool _preferDefaultLoadContext;
        private readonly string[] _resourceRoots;
        private readonly bool _loadInMemory;
        private readonly bool _lazyLoadReferences;
        private readonly AssemblyLoadContext _defaultLoadContext;
#if FEATURE_NATIVE_RESOLVER
        private readonly AssemblyDependencyResolver _dependencyResolver;
#endif
        private readonly bool _shadowCopyNativeLibraries;
        private readonly string _unmanagedDllShadowCopyDirectoryPath;

        public ManagedLoadContext(string mainAssemblyPath,
            IReadOnlyDictionary<string, ManagedLibrary> managedAssemblies,
            IReadOnlyDictionary<string, NativeLibrary> nativeLibraries,
            IReadOnlyCollection<string> privateAssemblies,
            IReadOnlyCollection<string> defaultAssemblies,
            IReadOnlyCollection<string> additionalProbingPaths,
            IReadOnlyCollection<string> resourceProbingPaths,
            AssemblyLoadContext defaultLoadContext,
            bool preferDefaultLoadContext,
            bool lazyLoadReferences,
            bool isCollectible,
            bool loadInMemory,
            bool shadowCopyNativeLibraries)
#if FEATURE_UNLOAD
            : base(Path.GetFileNameWithoutExtension(mainAssemblyPath), isCollectible)
#endif
        {
            if (resourceProbingPaths == null)
            {
                throw new ArgumentNullException(nameof(resourceProbingPaths));
            }

            _mainAssemblyPath = mainAssemblyPath ?? throw new ArgumentNullException(nameof(mainAssemblyPath));
#if FEATURE_NATIVE_RESOLVER
            _dependencyResolver = new AssemblyDependencyResolver(mainAssemblyPath);
#endif
            _basePath = Path.GetDirectoryName(mainAssemblyPath) ?? throw new ArgumentException(nameof(mainAssemblyPath));
            _managedAssemblies = managedAssemblies ?? throw new ArgumentNullException(nameof(managedAssemblies));
            _privateAssemblies = privateAssemblies ?? throw new ArgumentNullException(nameof(privateAssemblies));
            _defaultAssemblies = defaultAssemblies != null ? defaultAssemblies.ToList() : throw new ArgumentNullException(nameof(defaultAssemblies));
            _nativeLibraries = nativeLibraries ?? throw new ArgumentNullException(nameof(nativeLibraries));
            _additionalProbingPaths = additionalProbingPaths ?? throw new ArgumentNullException(nameof(additionalProbingPaths));
            _defaultLoadContext = defaultLoadContext;
            _preferDefaultLoadContext = preferDefaultLoadContext;
            _loadInMemory = loadInMemory;
            _lazyLoadReferences = lazyLoadReferences;

            _resourceRoots = new[] { _basePath }
                .Concat(resourceProbingPaths)
                .ToArray();

            _shadowCopyNativeLibraries = shadowCopyNativeLibraries;
            _unmanagedDllShadowCopyDirectoryPath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());

            if (shadowCopyNativeLibraries)
            {
                Unloading += _ => OnUnloaded();
            }
        }

        /// <summary>
        /// Load an assembly.
        /// </summary>
        /// <param name="assemblyName"></param>
        /// <returns></returns>
        protected override Assembly? Load(AssemblyName assemblyName)
        {
            if (assemblyName.Name == null)
            {
                // not sure how to handle this case. It's technically possible.
                return null;
            }

            if ((_preferDefaultLoadContext || _defaultAssemblies.Contains(assemblyName.Name)) && !_privateAssemblies.Contains(assemblyName.Name))
            {
                // If default context is preferred, check first for types in the default context unless the dependency has been declared as private
                try
                {
                    var defaultAssembly = _defaultLoadContext.LoadFromAssemblyName(assemblyName);
                    if (defaultAssembly != null)
                    {
                        // Add referenced assemblies to the list of default assemblies.
                        // This is basically lazy loading
                        if (_lazyLoadReferences)
                        {
                            foreach (var reference in defaultAssembly.GetReferencedAssemblies())
                            {
                                if (reference.Name != null && !_defaultAssemblies.Contains(reference.Name))
                                {
                                    _defaultAssemblies.Add(reference.Name);
                                }
                            }
                        }

                        // Older versions used to return null here such that returned assembly would be resolved from the default ALC.
                        // However, with the addition of custom default ALCs, the Default ALC may not be the user's chosen ALC when
                        // this context was built. As such, we simply return the Assembly from the user's chosen default load context.
                        return defaultAssembly;
                    }
                }
                catch
                {
                    // Swallow errors in loading from the default context
                }
            }

#if FEATURE_NATIVE_RESOLVER
            var resolvedPath = _dependencyResolver.ResolveAssemblyToPath(assemblyName);
            if (!string.IsNullOrEmpty(resolvedPath) && File.Exists(resolvedPath))
            {
                return LoadAssemblyFromFilePath(resolvedPath);
            }
#endif

            // Resource assembly binding does not use the TPA. Instead, it probes PLATFORM_RESOURCE_ROOTS (a list of folders)
            // for $folder/$culture/$assemblyName.dll
            // See https://github.com/dotnet/coreclr/blob/3fca50a36e62a7433d7601d805d38de6baee7951/src/binder/assemblybinder.cpp#L1232-L1290

            if (!string.IsNullOrEmpty(assemblyName.CultureName) && !string.Equals("neutral", assemblyName.CultureName))
            {
                foreach (var resourceRoot in _resourceRoots)
                {
                    var resourcePath = Path.Combine(resourceRoot, assemblyName.CultureName, assemblyName.Name + ".dll");
                    if (File.Exists(resourcePath))
                    {
                        return LoadAssemblyFromFilePath(resourcePath);
                    }
                }

                return null;
            }

            if (_managedAssemblies.TryGetValue(assemblyName.Name, out var library) && library != null)
            {
                if (SearchForLibrary(library, out var path) && path != null)
                {
                    return LoadAssemblyFromFilePath(path);
                }
            }
            else
            {
                // if an assembly was not listed in the list of known assemblies,
                // fallback to the load context base directory
                var dllName = assemblyName.Name + ".dll";
                foreach (var probingPath in _additionalProbingPaths.Prepend(_basePath))
                {
                    var localFile = Path.Combine(probingPath, dllName);
                    if (File.Exists(localFile))
                    {
                        return LoadAssemblyFromFilePath(localFile);
                    }
                }
            }

            return null;
        }

        public Assembly LoadAssemblyFromFilePath(string path)
        {
            if (!_loadInMemory)
            {
                return LoadFromAssemblyPath(path);
            }

            using var file = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.Read);
            var pdbPath = Path.ChangeExtension(path, ".pdb");
            if (File.Exists(pdbPath))
            {
                using var pdbFile = File.Open(pdbPath, FileMode.Open, FileAccess.Read, FileShare.Read);
                return LoadFromStream(file, pdbFile);
            }
            return LoadFromStream(file);

        }

        /// <summary>
        /// Loads the unmanaged binary using configured list of native libraries.
        /// </summary>
        /// <param name="unmanagedDllName"></param>
        /// <returns></returns>
        protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
        {
#if FEATURE_NATIVE_RESOLVER
            var resolvedPath = _dependencyResolver.ResolveUnmanagedDllToPath(unmanagedDllName);
            if (!string.IsNullOrEmpty(resolvedPath) && File.Exists(resolvedPath))
            {
                return LoadUnmanagedDllFromResolvedPath(resolvedPath, normalizePath: false);
            }
#endif

            foreach (var prefix in PlatformInformation.NativeLibraryPrefixes)
            {
                if (_nativeLibraries.TryGetValue(prefix + unmanagedDllName, out var library))
                {
                    if (SearchForLibrary(library, prefix, out var path) && path != null)
                    {
                        return LoadUnmanagedDllFromResolvedPath(path);
                    }
                }
                else
                {
                    // coreclr allows code to use [DllImport("sni")] or [DllImport("sni.dll")]
                    // This library treats the file name without the extension as the lookup name,
                    // so this loop is necessary to check if the unmanaged name matches a library
                    // when the file extension has been trimmed.
                    foreach (var suffix in PlatformInformation.NativeLibraryExtensions)
                    {
                        if (!unmanagedDllName.EndsWith(suffix, StringComparison.OrdinalIgnoreCase))
                        {
                            continue;
                        }

                        // check to see if there is a library entry for the library without the file extension
                        var trimmedName = unmanagedDllName.Substring(0, unmanagedDllName.Length - suffix.Length);

                        if (_nativeLibraries.TryGetValue(prefix + trimmedName, out library))
                        {
                            if (SearchForLibrary(library, prefix, out var path) && path != null)
                            {
                                return LoadUnmanagedDllFromResolvedPath(path);
                            }
                        }
                        else
                        {
                            // fallback to native assets which match the file name in the plugin base directory
                            var prefixSuffixDllName = prefix + unmanagedDllName + suffix;
                            var prefixDllName = prefix + unmanagedDllName;

                            foreach (var probingPath in _additionalProbingPaths.Prepend(_basePath))
                            {
                                var localFile = Path.Combine(probingPath, prefixSuffixDllName);
                                if (File.Exists(localFile))
                                {
                                    return LoadUnmanagedDllFromResolvedPath(localFile);
                                }

                                var localFileWithoutSuffix = Path.Combine(probingPath, prefixDllName);
                                if (File.Exists(localFileWithoutSuffix))
                                {
                                    return LoadUnmanagedDllFromResolvedPath(localFileWithoutSuffix);
                                }
                            }

                        }
                    }

                }
            }

            return base.LoadUnmanagedDll(unmanagedDllName);
        }

        private bool SearchForLibrary(ManagedLibrary library, out string? path)
        {
            // 1. Check for in _basePath + app local path
            var localFile = Path.Combine(_basePath, library.AppLocalPath);
            if (File.Exists(localFile))
            {
                path = localFile;
                return true;
            }

            // 2. Search additional probing paths
            foreach (var searchPath in _additionalProbingPaths)
            {
                var candidate = Path.Combine(searchPath, library.AdditionalProbingPath);
                if (File.Exists(candidate))
                {
                    path = candidate;
                    return true;
                }
            }

            // 3. Search in base path
            foreach (var ext in PlatformInformation.ManagedAssemblyExtensions)
            {
                var local = Path.Combine(_basePath, library.Name.Name + ext);
                if (File.Exists(local))
                {
                    path = local;
                    return true;
                }
            }

            path = null;
            return false;
        }

        private bool SearchForLibrary(NativeLibrary library, string prefix, out string? path)
        {
            // 1. Search in base path
            foreach (var ext in PlatformInformation.NativeLibraryExtensions)
            {
                var candidate = Path.Combine(_basePath, $"{prefix}{library.Name}{ext}");
                if (File.Exists(candidate))
                {
                    path = candidate;
                    return true;
                }
            }

            // 2. Search in base path + app local (for portable deployments of netcoreapp)
            var local = Path.Combine(_basePath, library.AppLocalPath);
            if (File.Exists(local))
            {
                path = local;
                return true;
            }

            // 3. Search additional probing paths
            foreach (var searchPath in _additionalProbingPaths)
            {
                var candidate = Path.Combine(searchPath, library.AdditionalProbingPath);
                if (File.Exists(candidate))
                {
                    path = candidate;
                    return true;
                }
            }

            path = null;
            return false;
        }

        private IntPtr LoadUnmanagedDllFromResolvedPath(string unmanagedDllPath, bool normalizePath = true)
        {
            if (normalizePath)
            {
                unmanagedDllPath = Path.GetFullPath(unmanagedDllPath);
            }

            return _shadowCopyNativeLibraries
                ? LoadUnmanagedDllFromShadowCopy(unmanagedDllPath)
                : LoadUnmanagedDllFromPath(unmanagedDllPath);
        }

        private IntPtr LoadUnmanagedDllFromShadowCopy(string unmanagedDllPath)
        {
            var shadowCopyDllPath = CreateShadowCopy(unmanagedDllPath);

            return LoadUnmanagedDllFromPath(shadowCopyDllPath);
        }

        private string CreateShadowCopy(string dllPath)
        {
            Directory.CreateDirectory(_unmanagedDllShadowCopyDirectoryPath);

            var dllFileName = Path.GetFileName(dllPath);
            var shadowCopyPath = Path.Combine(_unmanagedDllShadowCopyDirectoryPath, dllFileName);

            if (!File.Exists(shadowCopyPath))
            {
                File.Copy(dllPath, shadowCopyPath);
            }

            return shadowCopyPath;
        }

        private void OnUnloaded()
        {
            if (!_shadowCopyNativeLibraries || !Directory.Exists(_unmanagedDllShadowCopyDirectoryPath))
            {
                return;
            }

            // Attempt to delete shadow copies
            try
            {
                Directory.Delete(_unmanagedDllShadowCopyDirectoryPath, recursive: true);
            }
            catch (Exception)
            {
                // Files might be locked by host process. Nothing we can do about it, I guess.
            }
        }
    }
}ï»¿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text.Json;

namespace McMaster.NETCore.Plugins.Loader
{
    /// <summary>
    /// Extensions for creating a load context using settings from a runtimeconfig.json file
    /// </summary>
    public static class RuntimeConfigExtensions
    {
        private const string JsonExt = ".json";
        private static readonly JsonSerializerOptions s_serializerOptions = new()
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        /// <summary>
        /// Adds additional probing paths to a managed load context using settings found in the runtimeconfig.json
        /// and runtimeconfig.dev.json files.
        /// </summary>
        /// <param name="builder">The context builder</param>
        /// <param name="runtimeConfigPath">The path to the runtimeconfig.json file</param>
        /// <param name="includeDevConfig">Also read runtimeconfig.dev.json file, if present.</param>
        /// <param name="error">The error, if one occurs while parsing runtimeconfig.json</param>
        /// <returns>The builder.</returns>
        public static AssemblyLoadContextBuilder TryAddAdditionalProbingPathFromRuntimeConfig(
            this AssemblyLoadContextBuilder builder,
            string runtimeConfigPath,
            bool includeDevConfig,
            out Exception? error)
        {
            error = null;
            try
            {
                var config = TryReadConfig(runtimeConfigPath);
                if (config == null)
                {
                    return builder;
                }

                RuntimeConfig? devConfig = null;
                if (includeDevConfig)
                {
                    var configDevPath = runtimeConfigPath.Substring(0, runtimeConfigPath.Length - JsonExt.Length) + ".dev.json";
                    devConfig = TryReadConfig(configDevPath);
                }

                var tfm = config.runtimeOptions?.Tfm ?? devConfig?.runtimeOptions?.Tfm;

                if (config.runtimeOptions != null)
                {
                    AddProbingPaths(builder, config.runtimeOptions, tfm);
                }

                if (devConfig?.runtimeOptions != null)
                {
                    AddProbingPaths(builder, devConfig.runtimeOptions, tfm);
                }

                if (tfm != null)
                {
                    var dotnet = Process.GetCurrentProcess().MainModule.FileName;
                    if (string.Equals(Path.GetFileNameWithoutExtension(dotnet), "dotnet", StringComparison.OrdinalIgnoreCase))
                    {
                        var dotnetHome = Path.GetDirectoryName(dotnet);
                        if (dotnetHome != null)
                        {
                            builder.AddProbingPath(Path.Combine(dotnetHome, "store", RuntimeInformation.OSArchitecture.ToString().ToLowerInvariant(), tfm));
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                error = ex;
            }
            return builder;
        }

        private static void AddProbingPaths(AssemblyLoadContextBuilder builder, RuntimeOptions options, string? tfm)
        {
            if (options.AdditionalProbingPaths == null)
            {
                return;
            }

            foreach (var item in options.AdditionalProbingPaths)
            {
                var path = item;
                if (path.Contains("|arch|"))
                {
                    path = path.Replace("|arch|", RuntimeInformation.OSArchitecture.ToString().ToLowerInvariant());
                }

                if (path.Contains("|tfm|"))
                {
                    if (tfm == null)
                    {
                        // We don't have enough information to parse this
                        continue;
                    }

                    path = path.Replace("|tfm|", tfm);
                }

                builder.AddProbingPath(path);
            }
        }

        private static RuntimeConfig? TryReadConfig(string path)
        {
            try
            {
                var file = File.ReadAllBytes(path);
                return JsonSerializer.Deserialize<RuntimeConfig>(file, s_serializerOptions);
            }
            catch
            {
                return null;
            }
        }
    }
}ï»¿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;

namespace McMaster.NETCore.Plugins.LibraryModel
{
    /// <summary>
    /// Represents a managed, .NET assembly.
    /// </summary>
    [DebuggerDisplay("{Name} = {AdditionalProbingPath}")]
    public class ManagedLibrary
    {
        private ManagedLibrary(AssemblyName name, string additionalProbingPath, string appLocalPath)
        {
            Name = name ?? throw new ArgumentNullException(nameof(name));
            AdditionalProbingPath = additionalProbingPath ?? throw new ArgumentNullException(nameof(additionalProbingPath));
            AppLocalPath = appLocalPath ?? throw new ArgumentNullException(nameof(appLocalPath));
        }

        /// <summary>
        /// Name of the managed library
        /// </summary>
        public AssemblyName Name { get; private set; }

        /// <summary>
        /// Contains path to file within an additional probing path root. This is typically a combination
        /// of the NuGet package ID (lowercased), version, and path within the package.
        /// <para>
        /// For example, <c>microsoft.data.sqlite/1.0.0/lib/netstandard1.3/Microsoft.Data.Sqlite.dll</c>
        /// </para>
        /// </summary>
        public string AdditionalProbingPath { get; private set; }

        /// <summary>
        /// Contains path to file within a deployed, framework-dependent application.
        /// <para>
        /// For most managed libraries, this will be the file name.
        /// For example, <c>MyPlugin1.dll</c>.
        /// </para>
        /// <para>
        /// For runtime-specific managed implementations, this may include a sub folder path.
        /// For example, <c>runtimes/win/lib/netcoreapp2.0/System.Diagnostics.EventLog.dll</c>
        /// </para>
        /// </summary>
        public string AppLocalPath { get; private set; }

        /// <summary>
        /// Create an instance of <see cref="ManagedLibrary" /> from a NuGet package.
        /// </summary>
        /// <param name="packageId">The name of the package.</param>
        /// <param name="packageVersion">The version of the package.</param>
        /// <param name="assetPath">The path within the NuGet package.</param>
        /// <returns></returns>
        public static ManagedLibrary CreateFromPackage(string packageId, string packageVersion, string assetPath)
        {
            // When the asset comes from "lib/$tfm/", Microsoft.NET.Sdk will flatten this during publish based on the most compatible TFM.
            // The SDK will not flatten managed libraries found under runtimes/
            var appLocalPath = assetPath.StartsWith("lib/")
                ? Path.GetFileName(assetPath)
                : assetPath;

            return new ManagedLibrary(
                new AssemblyName(Path.GetFileNameWithoutExtension(assetPath)),
                Path.Combine(packageId.ToLowerInvariant(), packageVersion, assetPath),
                appLocalPath
            );
        }
    }
}
ï»¿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Diagnostics;
using System.IO;

namespace McMaster.NETCore.Plugins.LibraryModel
{
    /// <summary>
    /// Represents an unmanaged library, such as `libsqlite3`, which may need to be loaded
    /// for P/Invoke to work.
    /// </summary>
    [DebuggerDisplay("{Name} = {AdditionalProbingPath}")]
    public class NativeLibrary
    {
        private NativeLibrary(string name, string appLocalPath, string additionalProbingPath)
        {
            Name = name ?? throw new ArgumentNullException(nameof(name));
            AppLocalPath = appLocalPath ?? throw new ArgumentNullException(nameof(appLocalPath));
            AdditionalProbingPath = additionalProbingPath ?? throw new ArgumentNullException(nameof(additionalProbingPath));
        }

        /// <summary>
        /// Name of the native library. This should match the name of the P/Invoke call.
        /// <para>
        /// For example, if specifying `[DllImport("sqlite3")]`, <see cref="Name" /> should be <c>sqlite3</c>.
        /// This may not match the exact file name as loading will attempt variations on the name according
        /// to OS convention. On Windows, P/Invoke will attempt to load `sqlite3.dll`. On macOS, it will
        /// attempt to find `sqlite3.dylib` and `libsqlite3.dylib`. On Linux, it will attempt to find
        /// `sqlite3.so` and `libsqlite3.so`.
        /// </para>
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Contains path to file within a deployed, framework-dependent application
        /// <para>
        /// For example, <c>runtimes/linux-x64/native/libsqlite.so</c>
        /// </para>
        /// </summary>
        public string AppLocalPath { get; private set; }

        /// <summary>
        /// Contains path to file within an additional probing path root. This is typically a combination
        /// of the NuGet package ID (lowercased), version, and path within the package.
        /// <para>
        /// For example, <c>sqlite/3.13.3/runtimes/linux-x64/native/libsqlite.so</c>
        /// </para>
        /// </summary>
        public string AdditionalProbingPath { get; private set; }

        /// <summary>
        /// Create an instance of <see cref="NativeLibrary" /> from a NuGet package.
        /// </summary>
        /// <param name="packageId">The name of the package.</param>
        /// <param name="packageVersion">The version of the package.</param>
        /// <param name="assetPath">The path within the NuGet package.</param>
        /// <returns></returns>
        public static NativeLibrary CreateFromPackage(string packageId, string packageVersion, string assetPath)
        {
            return new NativeLibrary(
                Path.GetFileNameWithoutExtension(assetPath),
                assetPath,
                Path.Combine(packageId.ToLowerInvariant(), packageVersion, assetPath)
            );
        }
    }
} ï»¿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Threading;
using System.Threading.Tasks;

namespace McMaster.NETCore.Plugins.Internal
{
    internal class Debouncer : IDisposable
    {
        private readonly CancellationTokenSource _cts = new();
        private readonly TimeSpan _waitTime;
        private int _counter;

        public Debouncer(TimeSpan waitTime)
        {
            _waitTime = waitTime;
        }

        public void Execute(Action action)
        {
            var current = Interlocked.Increment(ref _counter);

            Task.Delay(_waitTime).ContinueWith(task =>
            {
                // Is this the last task that was queued?
                if (current == _counter && !_cts.IsCancellationRequested)
                {
                    action();
                }

                task.Dispose();
            }, _cts.Token);
        }

        public void Dispose()
        {
            _cts.Cancel();
        }
    }
}ï»¿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace McMaster.NETCore.Plugins
{
    internal class PlatformInformation
    {
        public static readonly string[] NativeLibraryExtensions;
        public static readonly string[] NativeLibraryPrefixes;
        public static readonly string[] ManagedAssemblyExtensions = new[]
        {
                ".dll",
                ".ni.dll",
                ".exe",
                ".ni.exe"
        };

        static PlatformInformation()
        {
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                NativeLibraryPrefixes = new[] { "" };
                NativeLibraryExtensions = new[] { ".dll" };
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                NativeLibraryPrefixes = new[] { "", "lib", };
                NativeLibraryExtensions = new[] { ".dylib" };
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                NativeLibraryPrefixes = new[] { "", "lib" };
                NativeLibraryExtensions = new[] { ".so", ".so.1" };
            }
            else
            {
                Debug.Fail("Unknown OS type");
                NativeLibraryPrefixes = Array.Empty<string>();
                NativeLibraryExtensions = Array.Empty<string>();
            }
        }
    }
}ï»¿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

namespace McMaster.NETCore.Plugins
{
    internal class RuntimeConfig
    {
        public RuntimeOptions? runtimeOptions { get; set; }
    }
}ï»¿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

namespace McMaster.NETCore.Plugins
{
    internal class RuntimeOptions
    {
        public string? Tfm { get; set; }

        public string[]? AdditionalProbingPaths { get; set; }
    }
}// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System.Reflection;
using McMaster.NETCore.Plugins;
using Microsoft.AspNetCore.Mvc.ApplicationParts;

namespace Microsoft.Extensions.DependencyInjection
{
    /// <summary>
    /// Extends the MVC builder.
    /// </summary>
    public static class MvcPluginExtensions
    {
        /// <summary>
        /// Loads controllers and razor pages from a plugin assembly.
        /// <para>
        /// This creates a loader with <see cref="PluginConfig.PreferSharedTypes" /> set to <c>true</c>.
        /// If you need more control over shared types, use <see cref="AddPluginLoader" /> instead.
        /// </para>
        /// </summary>
        /// <param name="mvcBuilder">The MVC builder</param>
        /// <param name="assemblyFile">Full path the main .dll file for the plugin.</param>
        /// <returns>The builder</returns>
        public static IMvcBuilder AddPluginFromAssemblyFile(this IMvcBuilder mvcBuilder, string assemblyFile)
        {
            var plugin = PluginLoader.CreateFromAssemblyFile(
                assemblyFile, // create a plugin from for the .dll file
                config =>
                    // this ensures that the version of MVC is shared between this app and the plugin
                    config.PreferSharedTypes = true);

            return mvcBuilder.AddPluginLoader(plugin);
        }

        /// <summary>
        /// Loads controllers and razor pages from a plugin loader.
        /// <para>
        /// In order for this to work, the PluginLoader instance must be configured to share the types
        /// <see cref="ProvideApplicationPartFactoryAttribute" /> and <see cref="RelatedAssemblyAttribute" />
        /// (comes from Microsoft.AspNetCore.Mvc.Core.dll). The easiest way to ensure that is done correctly
        /// is to set <see cref="PluginConfig.PreferSharedTypes" /> to <c>true</c>.
        /// </para>
        /// </summary>
        /// <param name="mvcBuilder">The MVC builder</param>
        /// <param name="pluginLoader">An instance of PluginLoader.</param>
        /// <returns>The builder</returns>
        public static IMvcBuilder AddPluginLoader(this IMvcBuilder mvcBuilder, PluginLoader pluginLoader)
        {
            var pluginAssembly = pluginLoader.LoadDefaultAssembly();

            // This loads MVC application parts from plugin assemblies
            var partFactory = ApplicationPartFactory.GetApplicationPartFactory(pluginAssembly);
            foreach (var part in partFactory.GetApplicationParts(pluginAssembly))
            {
                mvcBuilder.PartManager.ApplicationParts.Add(part);
            }

            // This piece finds and loads related parts, such as MvcAppPlugin1.Views.dll.
            var relatedAssembliesAttrs = pluginAssembly.GetCustomAttributes<RelatedAssemblyAttribute>();
            foreach (var attr in relatedAssembliesAttrs)
            {
                var assembly = pluginLoader.LoadAssembly(attr.AssemblyFileName);
                partFactory = ApplicationPartFactory.GetApplicationPartFactory(assembly);
                foreach (var part in partFactory.GetApplicationParts(assembly))
                {
                    mvcBuilder.PartManager.ApplicationParts.Add(part);
                }
            }

            return mvcBuilder;
        }
    }
}
look at all previous code examples and chat messages and at below text and code and use it to improve the plugin system
This tutorial shows you how to create a customÂ AssemblyLoadContextÂ to load plugins. AnÂ AssemblyDependencyResolverÂ is used to resolve the dependencies of the plugin. The tutorial correctly isolates the plugin's dependencies from the hosting application. You'll learn how to:
Structure a project to support plugins.
Create a customÂ AssemblyLoadContextÂ to load each plugin.
Use theÂ System.Runtime.Loader.AssemblyDependencyResolverÂ type to allow plugins to have dependencies.
Author plugins that can be easily deployed by just copying the build artifacts.
Prerequisites
Install theÂ .NET 5 SDKÂ or a newer version.
Â Note
The sample code targets .NET 5, but all the features it uses were introduced in .NET Core 3.0 and are available in all .NET releases since then.
Create the application
The first step is to create the application:
Create a new folder, and in that folder run the following command:
.NET CLICopy
dotnet new console -o AppWithPlugin

To make building the project easier, create a Visual Studio solution file in the same folder. Run the following command:
.NET CLICopy
dotnet new sln

Run the following command to add the app project to the solution:
.NET CLICopy
dotnet sln add AppWithPlugin/AppWithPlugin.csproj

Now we can fill in the skeleton of our application. Replace the code in theÂ AppWithPlugin/Program.csÂ file with the following code:
C#Copy
using PluginBase;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace AppWithPlugin
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                if (args.Length == 1 && args[0] == "/d")
                {
                    Console.WriteLine("Waiting for any key...");
                    Console.ReadLine();
                }

                // Load commands from plugins.

                if (args.Length == 0)
                {
                    Console.WriteLine("Commands: ");
                    // Output the loaded commands.
                }
                else
                {
                    foreach (string commandName in args)
                    {
                        Console.WriteLine($"-- {commandName} --");

                        // Execute the command with the name passed as an argument.

                        Console.WriteLine();
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);
            }
        }
    }
}

Create the plugin interfaces
The next step in building an app with plugins is defining the interface the plugins need to implement. We suggest that you make a class library that contains any types that you plan to use for communicating between your app and plugins. This division allows you to publish your plugin interface as a package without having to ship your full application.
In the root folder of the project, runÂ dotnet new classlib -o PluginBase. Also, runÂ dotnet sln add PluginBase/PluginBase.csprojÂ to add the project to the solution file. Delete theÂ PluginBase/Class1.csÂ file, and create a new file in theÂ PluginBaseÂ folder namedÂ ICommand.csÂ with the following interface definition:
C#Copy
namespace PluginBase
{
    public interface ICommand
    {
        string Name { get; }
        string Description { get; }

        int Execute();
    }
}

ThisÂ ICommandÂ interface is the interface that all of the plugins will implement.
Now that theÂ ICommandÂ interface is defined, the application project can be filled in a little more. Add a reference from theÂ AppWithPluginÂ project to theÂ PluginBaseÂ project with theÂ dotnet add AppWithPlugin/AppWithPlugin.csproj reference PluginBase/PluginBase.csprojÂ command from the root folder.
Replace theÂ // Load commands from pluginsÂ comment with the following code snippet to enable it to load plugins from given file paths:
C#Copy
string[] pluginPaths = new string[]
{
    // Paths to plugins to load.
};

IEnumerable<ICommand> commands = pluginPaths.SelectMany(pluginPath =>
{
    Assembly pluginAssembly = LoadPlugin(pluginPath);
    return CreateCommands(pluginAssembly);
}).ToList();

Then replace theÂ // Output the loaded commandsÂ comment with the following code snippet:
C#Copy
foreach (ICommand command in commands)
{
    Console.WriteLine($"{command.Name}\t - {command.Description}");
}

Replace theÂ // Execute the command with the name passed as an argumentÂ comment with the following snippet:
C#Copy
ICommand command = commands.FirstOrDefault(c => c.Name == commandName);
if (command == null)
{
    Console.WriteLine("No such command is known.");
    return;
}

command.Execute();

And finally, add static methods to theÂ ProgramÂ class namedÂ LoadPluginÂ andÂ CreateCommands, as shown here:
C#Copy
static Assembly LoadPlugin(string relativePath)
{
    throw new NotImplementedException();
}

static IEnumerable<ICommand> CreateCommands(Assembly assembly)
{
    int count = 0;

    foreach (Type type in assembly.GetTypes())
    {
        if (typeof(ICommand).IsAssignableFrom(type))
        {
            ICommand result = Activator.CreateInstance(type) as ICommand;
            if (result != null)
            {
                count++;
                yield return result;
            }
        }
    }

    if (count == 0)
    {
        string availableTypes = string.Join(",", assembly.GetTypes().Select(t => t.FullName));
        throw new ApplicationException(
            $"Can't find any type which implements ICommand in {assembly} from {assembly.Location}.\n" +
            $"Available types: {availableTypes}");
    }
}

Load plugins
Now the application can correctly load and instantiate commands from loaded plugin assemblies, but it's still unable to load the plugin assemblies. Create a file namedÂ PluginLoadContext.csÂ in theÂ AppWithPluginÂ folder with the following contents:
C#Copy
using System;
using System.Reflection;
using System.Runtime.Loader;

namespace AppWithPlugin
{
    class PluginLoadContext : AssemblyLoadContext
    {
        private AssemblyDependencyResolver _resolver;

        public PluginLoadContext(string pluginPath)
        {
            _resolver = new AssemblyDependencyResolver(pluginPath);
        }

        protected override Assembly Load(AssemblyName assemblyName)
        {
            string assemblyPath = _resolver.ResolveAssemblyToPath(assemblyName);
            if (assemblyPath != null)
            {
                return LoadFromAssemblyPath(assemblyPath);
            }

            return null;
        }

        protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
        {
            string libraryPath = _resolver.ResolveUnmanagedDllToPath(unmanagedDllName);
            if (libraryPath != null)
            {
                return LoadUnmanagedDllFromPath(libraryPath);
            }

            return IntPtr.Zero;
        }
    }
}

TheÂ PluginLoadContextÂ type derives fromÂ AssemblyLoadContext. TheÂ AssemblyLoadContextÂ type is a special type in the runtime that allows developers to isolate loaded assemblies into different groups to ensure that assembly versions don't conflict. Additionally, a customÂ AssemblyLoadContextÂ can choose different paths to load assemblies from and override the default behavior. TheÂ PluginLoadContextÂ uses an instance of theÂ AssemblyDependencyResolverÂ type introduced in .NET Core 3.0 to resolve assembly names to paths. TheÂ AssemblyDependencyResolverÂ object is constructed with the path to a .NET class library. It resolves assemblies and native libraries to their relative paths based on theÂ .deps.jsonÂ file for the class library whose path was passed to theÂ AssemblyDependencyResolverÂ constructor. The customÂ AssemblyLoadContextÂ enables plugins to have their own dependencies, and theÂ AssemblyDependencyResolverÂ makes it easy to correctly load the dependencies.
Now that theÂ AppWithPluginÂ project has theÂ PluginLoadContextÂ type, update theÂ Program.LoadPluginÂ method with the following body:
C#Copy
static Assembly LoadPlugin(string relativePath)
{
    // Navigate up to the solution root
    string root = Path.GetFullPath(Path.Combine(
        Path.GetDirectoryName(
            Path.GetDirectoryName(
                Path.GetDirectoryName(
                    Path.GetDirectoryName(
                        Path.GetDirectoryName(typeof(Program).Assembly.Location)))))));

    string pluginLocation = Path.GetFullPath(Path.Combine(root, relativePath.Replace('\\', Path.DirectorySeparatorChar)));
    Console.WriteLine($"Loading commands from: {pluginLocation}");
    PluginLoadContext loadContext = new PluginLoadContext(pluginLocation);
    return loadContext.LoadFromAssemblyName(new AssemblyName(Path.GetFileNameWithoutExtension(pluginLocation)));
}

By using a differentÂ PluginLoadContextÂ instance for each plugin, the plugins can have different or even conflicting dependencies without issue.
Simple plugin with no dependencies
Back in the root folder, do the following:
Run the following command to create a new class library project namedÂ HelloPlugin:
.NET CLICopy
dotnet new classlib -o HelloPlugin

Run the following command to add the project to theÂ AppWithPluginÂ solution:
.NET CLICopy
dotnet sln add HelloPlugin/HelloPlugin.csproj

Replace theÂ HelloPlugin/Class1.csÂ file with a file namedÂ HelloCommand.csÂ with the following contents:
C#Copy
using PluginBase;
using System;

namespace HelloPlugin
{
    public class HelloCommand : ICommand
    {
        public string Name { get => "hello"; }
        public string Description { get => "Displays hello message."; }

        public int Execute()
        {
            Console.WriteLine("Hello !!!");
            return 0;
        }
    }
}

Now, open theÂ HelloPlugin.csprojÂ file. It should look similar to the following:
XMLCopy
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net5.0</TargetFramework>
  </PropertyGroup>

</Project>


In between theÂ <PropertyGroup>Â tags, add the following element:
XMLCopy
  <EnableDynamicLoading>true</EnableDynamicLoading>

TheÂ <EnableDynamicLoading>true</EnableDynamicLoading>Â prepares the project so that it can be used as a plugin. Among other things, this will copy all of its dependencies to the output of the project. For more details seeÂ EnableDynamicLoading.
In between theÂ <Project>Â tags, add the following elements:
XMLCopy
<ItemGroup>
    <ProjectReference Include="..\PluginBase\PluginBase.csproj">
        <Private>false</Private>
        <ExcludeAssets>runtime</ExcludeAssets>
    </ProjectReference>
</ItemGroup>

TheÂ <Private>false</Private>Â element is important. This tells MSBuild to not copyÂ PluginBase.dllÂ to the output directory for HelloPlugin. If theÂ PluginBase.dllÂ assembly is present in the output directory,Â PluginLoadContextÂ will find the assembly there and load it when it loads theÂ HelloPlugin.dllÂ assembly. At this point, theÂ HelloPlugin.HelloCommandÂ type will implement theÂ ICommandÂ interface from theÂ PluginBase.dllÂ in the output directory of theÂ HelloPluginÂ project, not theÂ ICommandÂ interface that is loaded into the default load context. Since the runtime sees these two types as different types from different assemblies, theÂ AppWithPlugin.Program.CreateCommandsÂ method won't find the commands. As a result, theÂ <Private>false</Private>Â metadata is required for the reference to the assembly containing the plugin interfaces.
Similarly, theÂ <ExcludeAssets>runtime</ExcludeAssets>Â element is also important if theÂ PluginBaseÂ references other packages. This setting has the same effect asÂ <Private>false</Private>Â but works on package references that theÂ PluginBaseÂ project or one of its dependencies may include.
Now that theÂ HelloPluginÂ project is complete, you should update theÂ AppWithPluginÂ project to know where theÂ HelloPluginÂ plugin can be found. After theÂ // Paths to plugins to loadÂ comment, addÂ @"HelloPlugin\bin\Debug\net5.0\HelloPlugin.dll"Â (this path could be different based on the .NET Core version you use) as an element of theÂ pluginPathsÂ array.
Plugin with library dependencies
Almost all plugins are more complex than a simple "Hello World", and many plugins have dependencies on other libraries. TheÂ JsonPluginÂ andÂ OldJsonPluginÂ projects in the sample show two examples of plugins with NuGet package dependencies onÂ Newtonsoft.Json. Because of this, all plugin projects should addÂ <EnableDynamicLoading>true</EnableDynamicLoading>Â to the project properties so that they copy all of their dependencies to the output ofÂ dotnet build. Publishing the class library withÂ dotnet publishÂ will also copy all of its dependencies to the publish output.
Other examples in the sample
The complete source code for this tutorial can be found inÂ the dotnet/samples repository. The completed sample includes a few other examples ofÂ AssemblyDependencyResolverÂ behavior. For example, theÂ AssemblyDependencyResolverÂ object can also resolve native libraries as well as localized satellite assemblies included in NuGet packages. TheÂ UVPluginÂ andÂ FrenchPluginÂ in the samples repository demonstrate these scenarios.
Reference a plugin interface from a NuGet package
Let's say that there is an app A that has a plugin interface defined in the NuGet package namedÂ A.PluginBase. How do you reference the package correctly in your plugin project? For project references, using theÂ <Private>false</Private>Â metadata on theÂ ProjectReferenceÂ element in the project file prevented the dll from being copied to the output.
To correctly reference theÂ A.PluginBaseÂ package, you want to change theÂ <PackageReference>Â element in the project file to the following:
XMLCopy
<PackageReference Include="A.PluginBase" Version="1.0.0">
    <ExcludeAssets>runtime</ExcludeAssets>
</PackageReference>

This prevents theÂ A.PluginBaseÂ assemblies from being copied to the output directory of your plugin and ensures that your plugin will use A's version ofÂ A.PluginBase.
Plugin target framework recommendations
Because plugin dependency loading uses theÂ .deps.jsonÂ file, there is a gotcha related to the plugin's target framework. Specifically, your plugins should target a runtime, such as .NET 5, instead of a version of .NET Standard. TheÂ .deps.jsonÂ file is generated based on which framework the project targets, and since many .NET Standard-compatible packages ship reference assemblies for building against .NET Standard and implementation assemblies for specific runtimes, theÂ .deps.jsonÂ may not correctly see implementation assemblies, or it may grab the .NET Standard version of an assembly instead of the .NET Core version you expect.
Plugin framework references
Currently, plugins can't introduce new frameworks into the process. For example, you can't load a plugin that uses theÂ Microsoft.AspNetCore.AppÂ framework into an application that only uses the rootÂ Microsoft.NETCore.AppÂ framework. The host application must declare references to all frameworks needed by plugins.
Use above tutorial as basic idea - The interface should include plugin name , plugin description , which app or game launch the plugin targets , the app description , and any dependencies the plugin itself may have
plugins must load from a separate plugins directory , have a api interface available 
Loading Assemblies at Runtime
Now, we must code the plugin behavior we want to provide to our users. Letâs create the class:
Is this material useful to you? Consider subscribing and getÂ ASP.NET Core Web API Best PracticesÂ eBook forÂ FREE!

public class PluginLoadContext : AssemblyLoadContext
{
private AssemblyDependencyResolver _resolver;
public PluginLoadContext(string pluginPath)
{
_resolver = new AssemblyDependencyResolver(pluginPath);
}
}
Here, we create theÂ PluginLoadContextÂ class that inherits fromÂ AssemblyLoadContext, which allows us to work with plugin assemblies at runtime.
Now in theÂ ProgramÂ class, we can create a new method to do the assembly loading part:

static Assembly LoadPlugin(string assemblyPath)
{
Console.WriteLine($"Loading commands from: {assemblyPath}");
var loadContext = new PluginLoadContext(assemblyPath);
return loadContext.LoadFromAssemblyName(
new AssemblyName(Path.GetFileNameWithoutExtension(assemblyPath)));
}
Here, we define theÂ LoadPlugin()Â method that takes anÂ assemblyPathÂ as a parameter. With this, we create a new instance of ourÂ PluginLoadContextÂ class, providing theÂ assemblyPath. Finally, we call theÂ LoadFromAssemblyName()Â method, constructing anÂ AssemblyNameÂ object fromÂ assemblyName, returning the assembly.
Next, we will look at defining an interface that all plugins must implement so that they may be used in our host application.
Defining the Plugin Interface
Firstly, we create a new class library that holds our plugin interface. In our case, theÂ PluginBaseÂ project contains theÂ ICommandÂ plugin interface.Â We need to write an interface that properly provides our host application with everything required to run the plugin. This interface will be different for every application.
Letâs create one for our application:

public interface ICommand
{
string Name { get; }
string Description { get; }
int Invoke();
}
TheÂ ICommandÂ interface has three members: theÂ NameÂ andÂ DescriptionÂ properties, and theÂ Invoke()Â method. TheÂ NameÂ andÂ DescriptionÂ members are used to display to the user when we print the weather app plugins available for use. Finally, theÂ Invoke()Â method is what allows us to run the plugin.
Creating a Plugin
Letâs start creating our plugin by creating a new class library that produces our plugin assembly:
Is this material useful to you? Consider subscribing and getÂ ASP.NET Core Web API Best PracticesÂ eBook forÂ FREE!


dotnet new classlib -o TemperatureCommands

Next, letâs edit ourÂ .csprojÂ file for this app:

<PropertyGroup>
<EnableDynamicLoading>true</EnableDynamicLoading>
<PropertyGroup>
In the existingÂ <PropertyGroup />Â we enableÂ <EnableDynamicLoading />. This setting constructs the assembly, enabling its use as a plugin.
Further, we edit the project reference to theÂ PluginBaseÂ class library:

<ItemGroup>
<ProjectReference Include="..\PlugInBase\PlugInBase.csproj">
<Private>false</Private>
<ExcludeAssets>runtime</ExcludeAssets>
</ProjectReference>
</ItemGroup>
Firstly, theÂ <Private>Â setting tells the build to not make a copy ofÂ PluginBase.dllÂ in the output directory. Lastly,Â <ExcludesAssets>Â works in the same way but for dependencies of theÂ PluginBaseÂ assembly.
Now we can implement our plugin! Letâs begin by implementing theÂ ICommandÂ interface from theÂ PluginBaseÂ project we created in the last section:

public class TemperatureCommand : ICommand
{
public TemperatureCommand();
public string Name { get => "temperature"; }
public string Description { get => "Displays high and low temperatures for the users location."; }
public int Invoke()
{
Console.WriteLine("In your area, there will be high of 84F and a low of 69F.");
return 0;
}
}
Here, we implement theÂ Invoke()Â method, which serves as the entry point to the plugin. For this article, we simply log the weather data to the console.
Next, letâs tie all these pieces together as we load all plugins and give the user the option to choose a command.
Is this material useful to you? Consider subscribing and getÂ ASP.NET Core Web API Best PracticesÂ eBook forÂ FREE!
Running the Plugin From the Base Solution
Returning to theÂ WeatherAppHostÂ project, letâs implement theÂ Main()Â method:

public static void Main(string[] args)
{
try
{
var binDir = Environment.CurrentDirectory;
var files = Directory.GetFiles(binDir, "*.dll").ToList();
files.Remove(typeof(Program).Assembly.Location);
files.Remove(Path.Combine(binDir, "PlugInBase.dll"));
var commands = files.SelectMany(pluginPath =>
{
var pluginAssembly = LoadPlugin(pluginPath);
return CreateCommands(pluginAssembly);
}).ToList();
Console.WriteLine("Welcome to the Weather App.");
foreach (string commandName in args)
{
Console.WriteLine($"-- {commandName} --");
var command = commands.FirstOrDefault(c => c.Name == commandName);
if (command == null)
{
Console.WriteLine();
Console.WriteLine("No such command is known.");
return;
}
command.Invoke();
}
Console.WriteLine("\nApplication Closing");
}
catch (Exception ex)
{
Console.WriteLine(ex);
}
}
In theÂ Main()Â method, we search for all assemblies in our build directory, filter out the host app andÂ PluginBaseÂ assemblies, and load the remaining assemblies. From them, we get theÂ ICommandÂ objects which we can callÂ Invoke()Â based on the command line argument arrayÂ args.
TheÂ CreateCommands()Â method takes anÂ AssemblyÂ object and creates an instance of all classes that implementÂ ICommand:

static IEnumerable<ICommand> CreateCommands(Assembly assembly)
{
var count = 0;
foreach (var type in assembly.GetTypes())
{
if (type is not null &&
type.GetInterfaces().Any(intf => intf.FullName?.Contains(nameof(ICommand)) ?? false))
{
var result = Activator.CreateInstance(type) as ICommand;
if (result != null)
{
count++;
yield return result;
}
}
}
if (count == 0)
{
var availableTypes = string.Join(",", assembly.GetTypes().Select(t => t.FullName));
throw new ApplicationException(
$"Can't find any type which implements ICommand in {assembly} from {assembly.Location}.\n" +
$"Available types: {availableTypes}");
}
}
Here, we accept a pluginÂ AssemblyÂ object that is produced from theÂ LoadPlugin()Â method as an argument. We then iterate over allÂ TypeÂ objects contained in the assembly returned by theÂ GetTypes()Â method, checking if each implements theÂ ICommandÂ interface. If so, we create an instance of this type as anÂ ICommandÂ object. Finally, we return thisÂ ICommandÂ object. To sum up,Â this method returnsÂ ICommandÂ objects for all types that implementÂ ICommandÂ in the given assembly.
In the end, users can start the application and choose from a list of commands presented to them. Again, remember thatÂ each of these commands corresponds to an individual plugin assembly separate from our host app.Â 
Letâs take a look at the output of running theÂ temperatureÂ command:

Welcome to the Weather App.
-- temperature --
In your area, there will be high of 84F and a low of 69F.
Application Closing
Finally, now that we understand the general concept of a Plugin architecture and have developed a simple application, letâs discuss the pros and cons of enabling the plugin functionality in our apps.
have xml comments inside each code piece 
obviously  expand with anything else functionality wise that may be needed in WebLaunch project
for example one such thing to convert to a plugin would be Class1.cs which handles loading spellborn and ffxiv
The plugin interface must be generic , and call functions from secondary libraries and be robust and thread safe 
First, let's create the core interfaces in CoreFunctions.cs:

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.Loader;

namespace El_Garnan_Plugin_Loader
{
    public interface IGameLauncherPlugin
    {
        string Name { get; }
        string GameId { get; }
        Version Version { get; }
        Task<Process?> LaunchGameAsync(Dictionary<string, string> launchParameters);
    }

    public class PluginLoadContext : AssemblyLoadContext
    {
        private AssemblyDependencyResolver _resolver;

        public PluginLoadContext(string pluginPath)
        {
            _resolver = new AssemblyDependencyResolver(pluginPath);
        }

        protected override Assembly Load(AssemblyName assemblyName)
        {
            string? assemblyPath = _resolver.ResolveAssemblyToPath(assemblyName);
            if (assemblyPath != null)
            {
                return LoadFromAssemblyPath(assemblyPath);
            }
            return null;
        }

        protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
        {
            string? libraryPath = _resolver.ResolveUnmanagedDllToPath(unmanagedDllName);
            if (libraryPath != null)
            {
                return LoadUnmanagedDllFromPath(libraryPath);
            }
            return IntPtr.Zero;
        }
    }

    public class PluginManager
    {
        private readonly string _pluginsPath;
        private readonly Dictionary<string, IGameLauncherPlugin> _loadedPlugins = new();

        public PluginManager(string pluginsPath)
        {
            _pluginsPath = pluginsPath;
        }

        public void LoadPlugins()
        {
            if (!Directory.Exists(_pluginsPath))
            {
                Directory.CreateDirectory(_pluginsPath);
            }

            foreach (string pluginPath in Directory.GetFiles(_pluginsPath, "*.dll"))
            {
                var loadContext = new PluginLoadContext(pluginPath);
                var assembly = loadContext.LoadFromAssemblyPath(pluginPath);

                foreach (Type type in assembly.GetTypes())
                {
                    if (typeof(IGameLauncherPlugin).IsAssignableFrom(type) && !type.IsAbstract)
                    {
                        var plugin = (IGameLauncherPlugin)Activator.CreateInstance(type);
                        if (plugin != null)
                        {
                            _loadedPlugins[plugin.GameId] = plugin;
                        }
                    }
                }
            }
        }

        public IGameLauncherPlugin GetPlugin(string gameId)
        {
            return _loadedPlugins.TryGetValue(gameId, out var plugin) 
                ? plugin 
                : throw new KeyNotFoundException($"Plugin for game {gameId} not found");
        }
    }
}

Copy

Apply

Now let's modify Program.cs to use the plugin system:

// Add to existing using statements
using El_Garnan_Plugin_Loader;

class Program 
{
    private static readonly PluginManager _pluginManager;

    static Program()
    {
        string pluginsPath = Path.Combine(GetInstallPath(), "Plugins");
        _pluginManager = new PluginManager(pluginsPath);
        _pluginManager.LoadPlugins();
    }

    // Modify the existing FFXIV launch code to use plugins
    private static async Task HandleGameLaunch(string[] args)
    {
        try
        {
            var plugin = _pluginManager.GetPlugin("FFXIV");
            var launchParams = ParseLaunchParameters(args[0]);
            
            var process = await plugin.LaunchGameAsync(launchParams);
            if (process != null)
            {
                // Existing process handling code
            }
        }
        catch (Exception ex)
        {
            LogDebug($"Error launching game: {ex.Message}");
            ShowNotification("Error", "Failed to launch game");
        }
    }

    private static Dictionary<string, string> ParseLaunchParameters(string args)
    {
        // Parse URL parameters into dictionary
        var parameters = new Dictionary<string, string>();
        // Add parsing logic here
        return parameters;
    }
}

Copy

Apply

Example FFXIV plugin implementation:

public class FFXIVPlugin : IGameLauncherPlugin
{
    public string Name => "Final Fantasy XIV";
    public string GameId => "FFXIV";
    public Version Version => new Version(1, 0, 0);

    public async Task<Process?> LaunchGameAsync(Dictionary<string, string> parameters)
    {
        // Existing FFXIV launch logic goes here
        return await networklogic.LaunchGameAsync(
            parameters["gamePath"],
            parameters["sid"],
            int.Parse(parameters["language"]),
            bool.Parse(parameters["dx11"]),
            int.Parse(parameters["expansionLevel"]),
            bool.Parse(parameters["isSteam"]),
            int.Parse(parameters["region"]));
    }
}

Copy

Apply

This implementation:

Creates a plugin system with clean interfaces
Supports dynamic loading of game-specific plugins
Handles assembly loading and dependencies properly
Maintains isolation between plugins
Makes it easy to add new game launchers
Each game launcher can be implemented as a separate plugin DLL that implements IGameLauncherPlugin.
Yes, you're absolutely right! Let's modify the plugin system to use dynamic loading. Here's the improved implementation:

using System.Reflection;
using System.Runtime.Loader;

namespace El_Garnan_Plugin_Loader
{
    public class CoreFunctions
    {
        private readonly Dictionary<string, IGamePlugin> _loadedPlugins = new();
        private readonly string _pluginsPath;

        public CoreFunctions(string pluginsPath)
        {
            _pluginsPath = pluginsPath;
        }

        public async Task LoadPlugins()
        {
            foreach (string pluginPath in Directory.GetFiles(_pluginsPath, "*.dll"))
            {
                try
                {
                    var pluginAssembly = LoadPlugin(pluginPath);
                    var pluginTypes = GetPluginTypes(pluginAssembly);

                    foreach (Type type in pluginTypes)
                    {
                        if (Activator.CreateInstance(type) is IGamePlugin plugin)
                        {
                            await plugin.Initialize();
                            _loadedPlugins[plugin.PluginId] = plugin;
                        }
                    }
                }
                catch (Exception ex)
                {
                    // Log plugin load failure
                    Console.WriteLine($"Failed to load plugin {pluginPath}: {ex.Message}");
                }
            }
        }

        private Assembly LoadPlugin(string pluginPath)
        {
            var loadContext = new PluginLoadContext(pluginPath);
            return loadContext.LoadFromAssemblyPath(pluginPath);
        }

        private IEnumerable<Type> GetPluginTypes(Assembly assembly)
        {
            foreach (Type type in assembly.GetTypes())
            {
                if (typeof(IGamePlugin).IsAssignableFrom(type) && !type.IsAbstract)
                {
                    yield return type;
                }
            }
        }

        public IGamePlugin? GetPlugin(string pluginId)
        {
            return _loadedPlugins.TryGetValue(pluginId, out var plugin) ? plugin : null;
        }
    }

    class PluginLoadContext : AssemblyLoadContext
    {
        private AssemblyDependencyResolver _resolver;

        public PluginLoadContext(string pluginPath)
        {
            _resolver = new AssemblyDependencyResolver(pluginPath);
        }

        protected override Assembly? Load(AssemblyName assemblyName)
        {
            string? assemblyPath = _resolver.ResolveAssemblyToPath(assemblyName);
            if (assemblyPath != null)
            {
                return LoadFromAssemblyPath(assemblyPath);
            }
            return null;
        }

        protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
        {
            string? libraryPath = _resolver.ResolveUnmanagedDllToPath(unmanagedDllName);
            if (libraryPath != null)
            {
                return LoadUnmanagedDllFromPath(libraryPath);
            }
            return IntPtr.Zero;
        }
    }
}

Copy

Apply

This implementation:

Uses AssemblyLoadContext for proper plugin isolation
Implements dynamic loading of assemblies and dependencies
Handles unmanaged DLLs properly
Provides clean plugin lifecycle management



Claude 3.5 Sonnet (New)
I'll create the integration code for Program.cs to use the new plugin system:

// Add to existing using statements
using El_Garnan_Plugin_Loader;

// Inside Program class, add:
private static CoreFunctions _pluginSystem;

// Modify the Main method to initialize plugin system
static void Main(string[] args)
{
    var handle = GetConsoleWindow();
    ShowWindow(handle, SW_HIDE);

    // Initialize plugin system
    string pluginsPath = Path.Combine(GetInstallPath(), "Plugins");
    Directory.CreateDirectory(pluginsPath);
    _pluginSystem = new CoreFunctions(pluginsPath);
    
    // Load plugins at startup
    await _pluginSystem.LoadPlugins();

    // Modify the existing args handling to use plugins
    if (args[0].Contains("?ffxivhandle=yes"))
    {
        var ffxivPlugin = _pluginSystem.GetPlugin("ffxiv-launch");
        if (ffxivPlugin != null)
        {
            var parameters = ParseLaunchParameters(args[0]);
            await ffxivPlugin.LaunchGame(parameters);
        }
    }
    else if (args[0].Contains("?spellbornhandle=yes"))
    {
        var spellbornPlugin = _pluginSystem.GetPlugin("spellborn-launch");
        if (spellbornPlugin != null)
        {
            var parameters = new Dictionary<string, string>
            {
                ["args"] = args[0]
            };
            await spellbornPlugin.LaunchGame(parameters);
        }
    }
}

// Add helper method to parse launch parameters
private static Dictionary<string, string> ParseLaunchParameters(string args)
{
    var parameters = new Dictionary<string, string>();
    var pairs = args.Split('&');
    
    foreach (var pair in pairs)
    {
        var keyValue = pair.Split('=');
        if (keyValue.Length == 2)
        {
            parameters[keyValue[0]] = keyValue[1];
        }
    }
    
    return parameters;
}

Copy

Apply

Would you like me to show the plugin deployment structure or explain any specific part of the integration?

Try again with different context
Add context...
Avatar for rsgeeens-ctijr
1 sd
yes



Claude 3.5 Sonnet (New)
I'll show the plugin deployment structure and add the necessary build configurations:

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0-windows</TargetFramework>
    <EnableDynamicLoading>true</EnableDynamicLoading>
    <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\CoreLibLaunchSupport\CoreLibLaunchSupport.csproj">
      <Private>false</Private>
      <ExcludeAssets>runtime</ExcludeAssets>
    </ProjectReference>
  </ItemGroup>
</Project>

Copy

Apply

El'GarnanPluginSystem\El'GarnanPluginSystem.csproj
And here's how to set up the plugin deployment in the main application:

private static void DeployPlugins()
{
    string pluginsPath = Path.Combine(GetInstallPath(), "Plugins");
    
    // Create plugins directory structure
    var pluginDirs = new[]
    {
        Path.Combine(pluginsPath, "FFXIV"),
        Path.Combine(pluginsPath, "Spellborn")
    };

    foreach (var dir in pluginDirs)
    {
        Directory.CreateDirectory(dir);
    }

    // Copy plugin files on first run
    CopyPluginFiles(pluginsPath);
}

private static void CopyPluginFiles(string pluginsRoot)
{
    var pluginSources = new Dictionary<string, string>
    {
        ["FFXIV"] = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Plugins", "FFXIV"),
        ["Spellborn"] = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Plugins", "Spellborn")
    };

    foreach (var plugin in pluginSources)
    {
        if (Directory.Exists(plugin.Value))
        {
            var targetDir = Path.Combine(pluginsRoot, plugin.Key);
            foreach (var file in Directory.GetFiles(plugin.Value, "*.dll"))
            {
                var targetFile = Path.Combine(targetDir, Path.GetFileName(file));
                File.Copy(file, targetFile, true);
            }
        }
    }
}

Copy

Apply

This sets up a clean plugin deployment structure and ensures plugins are properly copied to their respective directories. Would you like me to show the logging integration or explain any other aspects?
Yes, I can help create a robust plugin system for WebLaunch. Here's how we can structure the core plugin interface and loader:

using System;
using System.Threading.Tasks;

namespace El_Garnan_Plugin_Loader.Interfaces
{
    /// <summary>
    /// Core interface that all game launch plugins must implement
    /// </summary>
    public interface IGamePlugin
    {
        /// <summary>
        /// Unique identifier for the plugin
        /// </summary>
        string PluginId { get; }

        /// <summary>
        /// Display name of the plugin
        /// </summary> 
        string Name { get; }

        /// <summary>
        /// Plugin description
        /// </summary>
        string Description { get; }

        /// <summary>
        /// Target game/application this plugin handles
        /// </summary>
        string TargetApplication { get; }

        /// <summary>
        /// Plugin version
        /// </summary>
        Version Version { get; }

        /// <summary>
        /// Initializes the plugin
        /// </summary>
        Task Initialize();

        /// <summary>
        /// Launches the target application with given parameters
        /// </summary>
        Task<bool> LaunchGame(IDictionary<string, string> launchParameters);

        /// <summary>
        /// Cleanup plugin resources
        /// </summary>
        Task Shutdown();
    }
}

Copy

Apply

using System.Reflection;
using System.Runtime.Loader;

namespace El_Garnan_Plugin_Loader
{
    public class CoreFunctions
    {
        private readonly string _pluginsPath;
        private readonly Dictionary<string, IGamePlugin> _loadedPlugins;
        private readonly AssemblyLoadContext _loadContext;

        public CoreFunctions(string pluginsPath)
        {
            _pluginsPath = pluginsPath;
            _loadedPlugins = new Dictionary<string, IGamePlugin>();
            _loadContext = new PluginLoadContext(pluginsPath);
        }

        /// <summary>
        /// Loads all plugins from the plugins directory
        /// </summary>
        public async Task LoadPlugins()
        {
            var pluginFiles = Directory.GetFiles(_pluginsPath, "*.dll");
            
            foreach(var file in pluginFiles)
            {
                try
                {
                    var assembly = _loadContext.LoadFromAssemblyPath(file);
                    var plugins = CreatePlugins(assembly);
                    
                    foreach(var plugin in plugins)
                    {
                        await plugin.Initialize();
                        _loadedPlugins[plugin.PluginId] = plugin;
                    }
                }
                catch(Exception ex)
                {
                    // Log plugin load failure
                }
            }
        }

        /// <summary>
        /// Gets a loaded plugin by ID
        /// </summary>
        public IGamePlugin GetPlugin(string pluginId)
        {
            return _loadedPlugins.TryGetValue(pluginId, out var plugin) ? plugin : null;
        }

        private IEnumerable<IGamePlugin> CreatePlugins(Assembly assembly)
        {
            foreach(var type in assembly.GetTypes())
            {
                if(typeof(IGamePlugin).IsAssignableFrom(type) && !type.IsAbstract)
                {
                    if(Activator.CreateInstance(type) is IGamePlugin plugin)
                    {
                        yield return plugin;
                    }
                }
            }
        }
    }
}

Copy

Apply

This provides a foundation for the plugin system. Would you like me to continue with implementation examples for FFXIV and Spellborn plugins, or would you like more details about any specific part?

Try again with different context
Public knowledge only
Current file only
Add context...
Avatar for rsgeeens-ctijr
1 sd
yes



Claude 3.5 Sonnet (New)
I'll create the FFXIV and Spellborn plugin implementations that integrate with the existing codebase:

using CoreLibLaunchSupport;
using El_Garnan_Plugin_Loader.Interfaces;

namespace El_Garnan_Plugin_Loader.Plugins
{
    public class FFXIVPlugin : IGamePlugin
    {
        private networklogic _networkHandler;
        private launchers _launcher;

        public string PluginId => "ffxiv-launch";
        public string Name => "Final Fantasy XIV Launcher";
        public string Description => "Handles launching of FFXIV with login credentials";
        public string TargetApplication => "Final Fantasy XIV";
        public Version Version => new Version(1, 0, 0);

        public async Task Initialize()
        {
            _networkHandler = new networklogic();
            _launcher = new launchers();
        }

        public async Task<bool> LaunchGame(IDictionary<string, string> parameters)
        {
            try
            {
                var sid = _networkHandler.GetRealSid(
                    parameters["gamePath"],
                    parameters["username"],
                    parameters["password"],
                    parameters.GetValueOrDefault("otp", ""),
                    bool.Parse(parameters.GetValueOrDefault("isSteam", "false"))
                );

                if (sid == "BAD")
                    return false;

                var process = await _networkHandler.LaunchGameAsync(
                    parameters["gamePath"],
                    sid,
                    int.Parse(parameters.GetValueOrDefault("language", "1")),
                    true, // dx11
                    int.Parse(parameters.GetValueOrDefault("expansionLevel", "6")),
                    bool.Parse(parameters.GetValueOrDefault("isSteam", "false")),
                    int.Parse(parameters.GetValueOrDefault("region", "3"))
                );

                return process != null;
            }
            catch
            {
                return false;
            }
        }

        public Task Shutdown()
        {
            return Task.CompletedTask;
        }
    }
}

Copy

Apply

using CoreLibLaunchSupport;
using El_Garnan_Plugin_Loader.Interfaces;

namespace El_Garnan_Plugin_Loader.Plugins
{
    public class SpellbornPlugin : IGamePlugin
    {
        private SpellbornSupporter _supporter;

        public string PluginId => "spellborn-launch";
        public string Name => "Chronicles of Spellborn Launcher";
        public string Description => "Handles launching of Chronicles of Spellborn";
        public string TargetApplication => "Chronicles of Spellborn";
        public Version Version => new Version(1, 0, 0);

        public Task Initialize()
        {
            _supporter = new SpellbornSupporter();
            return Task.CompletedTask;
        }

        public async Task<bool> LaunchGame(IDictionary<string, string> parameters)
        {
            try
            {
                string gamePath = _supporter.GetGamePathFromArgs(parameters["args"].Split(' '));
                Directory.SetCurrentDirectory(gamePath);
                _supporter.StartupRoutine(parameters["args"].Split(' '));
                return true;
            }
            catch
            {
                return false;
            }
        }

        public Task Shutdown()
        {
            return Task.CompletedTask;
        }
    }
}

Copy

Apply

These implementations integrate the existing launch logic into the plugin system while providing a clean interface. The plugins can be loaded dynamically and handle their specific game launch requirements through the unified IGamePlugin interface.

Would you like me to show how to integrate this into the main Program.cs or explain any specific part in more detail?
Yes, I can help create a robust plugin system for WebLaunch. Here's how we can structure the core plugin interface and loader:

using System;
using System.Threading.Tasks;

namespace El_Garnan_Plugin_Loader.Interfaces
{
    /// <summary>
    /// Core interface that all game launch plugins must implement
    /// </summary>
    public interface IGamePlugin
    {
        /// <summary>
        /// Unique identifier for the plugin
        /// </summary>
        string PluginId { get; }

        /// <summary>
        /// Display name of the plugin
        /// </summary> 
        string Name { get; }

        /// <summary>
        /// Plugin description
        /// </summary>
        string Description { get; }

        /// <summary>
        /// Target game/application this plugin handles
        /// </summary>
        string TargetApplication { get; }

        /// <summary>
        /// Plugin version
        /// </summary>
        Version Version { get; }

        /// <summary>
        /// Initializes the plugin
        /// </summary>
        Task Initialize();

        /// <summary>
        /// Launches the target application with given parameters
        /// </summary>
        Task<bool> LaunchGame(IDictionary<string, string> launchParameters);

        /// <summary>
        /// Cleanup plugin resources
        /// </summary>
        Task Shutdown();
    }
}

Copy

Apply

using System.Reflection;
using System.Runtime.Loader;

namespace El_Garnan_Plugin_Loader
{
    public class CoreFunctions
    {
        private readonly string _pluginsPath;
        private readonly Dictionary<string, IGamePlugin> _loadedPlugins;
        private readonly AssemblyLoadContext _loadContext;

        public CoreFunctions(string pluginsPath)
        {
            _pluginsPath = pluginsPath;
            _loadedPlugins = new Dictionary<string, IGamePlugin>();
            _loadContext = new PluginLoadContext(pluginsPath);
        }

        /// <summary>
        /// Loads all plugins from the plugins directory
        /// </summary>
        public async Task LoadPlugins()
        {
            var pluginFiles = Directory.GetFiles(_pluginsPath, "*.dll");
            
            foreach(var file in pluginFiles)
            {
                try
                {
                    var assembly = _loadContext.LoadFromAssemblyPath(file);
                    var plugins = CreatePlugins(assembly);
                    
                    foreach(var plugin in plugins)
                    {
                        await plugin.Initialize();
                        _loadedPlugins[plugin.PluginId] = plugin;
                    }
                }
                catch(Exception ex)
                {
                    // Log plugin load failure
                }
            }
        }

        /// <summary>
        /// Gets a loaded plugin by ID
        /// </summary>
        public IGamePlugin GetPlugin(string pluginId)
        {
            return _loadedPlugins.TryGetValue(pluginId, out var plugin) ? plugin : null;
        }

        private IEnumerable<IGamePlugin> CreatePlugins(Assembly assembly)
        {
            foreach(var type in assembly.GetTypes())
            {
                if(typeof(IGamePlugin).IsAssignableFrom(type) && !type.IsAbstract)
                {
                    if(Activator.CreateInstance(type) is IGamePlugin plugin)
                    {
                        yield return plugin;
                    }
                }
            }
        }
    }
}

Copy

Apply

This provides a foundation for the plugin system. Would you like me to continue with implementation examples for FFXIV and Spellborn plugins, or would you like more details about any specific part?

Try again with different context
Public knowledge only
Current file only
Add context...
Avatar for rsgeeens-ctijr
1 sd
yes



Claude 3.5 Sonnet (New)
I'll create the FFXIV and Spellborn plugin implementations that integrate with the existing codebase:

using CoreLibLaunchSupport;
using El_Garnan_Plugin_Loader.Interfaces;

namespace El_Garnan_Plugin_Loader.Plugins
{
    public class FFXIVPlugin : IGamePlugin
    {
        private networklogic _networkHandler;
        private launchers _launcher;

        public string PluginId => "ffxiv-launch";
        public string Name => "Final Fantasy XIV Launcher";
        public string Description => "Handles launching of FFXIV with login credentials";
        public string TargetApplication => "Final Fantasy XIV";
        public Version Version => new Version(1, 0, 0);

        public async Task Initialize()
        {
            _networkHandler = new networklogic();
            _launcher = new launchers();
        }

        public async Task<bool> LaunchGame(IDictionary<string, string> parameters)
        {
            try
            {
                var sid = _networkHandler.GetRealSid(
                    parameters["gamePath"],
                    parameters["username"],
                    parameters["password"],
                    parameters.GetValueOrDefault("otp", ""),
                    bool.Parse(parameters.GetValueOrDefault("isSteam", "false"))
                );

                if (sid == "BAD")
                    return false;

                var process = await _networkHandler.LaunchGameAsync(
                    parameters["gamePath"],
                    sid,
                    int.Parse(parameters.GetValueOrDefault("language", "1")),
                    true, // dx11
                    int.Parse(parameters.GetValueOrDefault("expansionLevel", "6")),
                    bool.Parse(parameters.GetValueOrDefault("isSteam", "false")),
                    int.Parse(parameters.GetValueOrDefault("region", "3"))
                );

                return process != null;
            }
            catch
            {
                return false;
            }
        }

        public Task Shutdown()
        {
            return Task.CompletedTask;
        }
    }
}

Copy

Apply

using CoreLibLaunchSupport;
using El_Garnan_Plugin_Loader.Interfaces;

namespace El_Garnan_Plugin_Loader.Plugins
{
    public class SpellbornPlugin : IGamePlugin
    {
        private SpellbornSupporter _supporter;

        public string PluginId => "spellborn-launch";
        public string Name => "Chronicles of Spellborn Launcher";
        public string Description => "Handles launching of Chronicles of Spellborn";
        public string TargetApplication => "Chronicles of Spellborn";
        public Version Version => new Version(1, 0, 0);

        public Task Initialize()
        {
            _supporter = new SpellbornSupporter();
            return Task.CompletedTask;
        }

        public async Task<bool> LaunchGame(IDictionary<string, string> parameters)
        {
            try
            {
                string gamePath = _supporter.GetGamePathFromArgs(parameters["args"].Split(' '));
                Directory.SetCurrentDirectory(gamePath);
                _supporter.StartupRoutine(parameters["args"].Split(' '));
                return true;
            }
            catch
            {
                return false;
            }
        }

        public Task Shutdown()
        {
            return Task.CompletedTask;
        }
    }
}

Copy

Apply

These implementations integrate the existing launch logic into the plugin system while providing a clean interface. The plugins can be loaded dynamically and handle their specific game launch requirements through the unified IGamePlugin interface.

Would you like me to show how to integrate this into the main Program.cs or explain any specific part in more detail?
using System;
class FailSoftArray {
int[] a; // ÑÑÑÐ»ÐºÐ° Ð½Ð° Ð±Ð°Ð·Ð¾Ð²ÑÐ¹ Ð¼Ð°ÑÑÐ¸Ð²
public int Length; // Ð¾ÑÐºÑÑÑÐ°Ñ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½Ð°Ñ Ð´Ð»Ð¸Ð½Ñ Ð¼Ð°ÑÑÐ¸Ð²Ð°
308 Ð§Ð°ÑÑÑ I. Ð¯Ð·ÑÐº C#
public bool ErrFlag; // Ð¾Ð±Ð¾Ð·Ð½Ð°ÑÐ°ÐµÑ ÑÐµÐ·ÑÐ»ÑÑÐ°Ñ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ¹ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¸
// ÐÐ¾ÑÑÑÐ¾Ð¸ÑÑ Ð¼Ð°ÑÑÐ¸Ð² Ð·Ð°Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ ÑÐ°Ð·Ð¼ÐµÑÐ°.
public FailSoftArray(int size) {
a = new int[size];
Length = size;
}
// Ð­ÑÐ¾ Ð¸Ð½Ð´ÐµÐºÑÐ°ÑÐ¾Ñ ÑÐ¸Ð¿Ð° int Ð´Ð»Ñ Ð¼Ð°ÑÑÐ¸Ð²Ð° FailSoftArray.
public int this[int index] {
// Ð­ÑÐ¾ Ð°ÐºÑÐµÑÑÐ¾Ñ get.
get {
if(ok(index)) {
ErrFlag = false;
return a[index];
} else {
ErrFlag = true;
}return 0;
}
// Ð­ÑÐ¾ Ð°ÐºÑÐµÑÑÐ¾Ñ set.
set {
if(ok(index)) {
a[index] = value;
}ErrFlag = false;
}else ErrFlag = true;
}
/* Ð­ÑÐ¾ ÐµÑÐµ Ð¾Ð´Ð¸Ð½ Ð¸Ð½Ð´ÐµÐºÑÐ°ÑÐ¾Ñ Ð´Ð»Ñ Ð¼Ð°ÑÑÐ¸Ð²Ð° FailSoftArray.
ÐÐ½ Ð¾ÐºÑÑÐ³Ð»ÑÐµÑ ÑÐ²Ð¾Ð¹ Ð°ÑÐ³ÑÐ¼ÐµÐ½Ñ Ð´Ð¾ Ð±Ð»Ð¸Ð¶Ð°Ð¹ÑÐµÐ³Ð¾ ÑÐµÐ»Ð¾Ð³Ð¾ Ð¸Ð½Ð´ÐµÐºÑÐ°. */
public int this[double idx] {
// Ð­ÑÐ¾ Ð°ÐºÑÐµÑÑÐ¾Ñ get.
get {
int index;
// ÐÐºÑÑÐ³Ð»Ð¸ÑÑ Ð´Ð¾ Ð±Ð»Ð¸Ð¶Ð°Ð¹ÑÐµÐ³Ð¾ ÑÐµÐ»Ð¾Ð³Ð¾.
if( (idx - (int) idx) < 0.5) index = (int) idx;
else index = (int) idx + 1;
if(ok(index)) {
ErrFlag = false;
return a[index];
} else {
ErrFlag = true;
}return 0;
}
// Ð­ÑÐ¾ Ð°ÐºÑÐµÑÑÐ¾Ñ set.
set {
int index;
ÐÐ»Ð°Ð²Ð° 10. ÐÐ½Ð´ÐµÐºÑÐ°ÑÐ¾ÑÑ Ð¸ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð° 309
// ÐÐºÑÑÐ³Ð»Ð¸ÑÑ Ð´Ð¾ Ð±Ð»Ð¸Ð¶Ð°Ð¹ÑÐµÐ³Ð¾ ÑÐµÐ»Ð¾Ð³Ð¾.
if( (idx - (int) idx) < 0.5) index = (int) idx;
else index = (int) idx + 1;
if(ok(index)) {
a[index] = value;
}ErrFlag = false;
}else ErrFlag = true;
}
// ÐÐ¾Ð·Ð²ÑÐ°ÑÐ¸ÑÑ Ð»Ð¾Ð³Ð¸ÑÐµÑÐºÐ¾Ðµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ true, ÐµÑÐ»Ð¸
// Ð¸Ð½Ð´ÐµÐºÑ Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð² ÑÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð½ÑÑ Ð³ÑÐ°Ð½Ð¸ÑÐ°Ñ.
private bool ok(int index) {
if (index >= 0 & index < Length) return true;
return false;
}
}
// ÐÑÐ¾Ð´ÐµÐ¼Ð¾Ð½ÑÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð¿ÑÐ¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ð¾ÑÐºÐ°Ð·Ð¾ÑÑÑÐ¾Ð¹ÑÐ¸Ð²Ð¾Ð³Ð¾ Ð¼Ð°ÑÑÐ¸Ð²Ð°.
class FSDemo {
static void Main() {
FailSoftArray fs = new FailSoftArray(5);
// ÐÐ¾Ð¼ÐµÑÑÐ¸ÑÑ ÑÑÐ´ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ð¹ Ð² Ð¼Ð°ÑÑÐ¸Ð² fs.
for(int i=0; i < fs.Length; i++)
fs[i] = i;
// Ð ÑÐµÐ¿ÐµÑÑ Ð²Ð¾ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑÑÑ Ð¸Ð½Ð´ÐµÐºÑÐ°Ð¼Ð¸
// ÑÐ¸Ð¿Ð° int Ð¸ double Ð´Ð»Ñ Ð¾Ð±ÑÐ°ÑÐµÐ½Ð¸Ñ Ðº Ð¼Ð°ÑÑÐ¸Ð²Ñ.
Console.WriteLine("fs[1] : " + fs[1]);
Console.WriteLine("fs[2] : " + fs[2]);
Console.WriteLine("fs[1.1]: " + fs[l.l]);
}Console.WriteLine("fs[1.6]: " + fs[1.6]);
}